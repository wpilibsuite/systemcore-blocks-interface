// This file was generated. Do not edit!

import * as pythonEnum from "../mrc_get_python_enum_value";
import * as toolboxItems from "../../toolbox/items";

// Blocks for class wpilib.LEDPattern

export function initialize() {
  pythonEnum.initializeEnum("wpilib.LEDPattern.GradientType", ["kContinuous", "kDiscontinuous"], "Types of gradients.\n\nMembers:\n\n  kContinuous : A continuous gradient, where the gradient wraps around to allow for\nseamless scrolling effects.\n\n  kDiscontinuous : A discontinuous gradient, where the first pixel is set to the first color\nof the gradient and the final pixel is set to the last color of the\ngradient. There is no wrapping effect, so scrolling effects will display\nan obvious seam.");
}

export function getToolboxCategory(subcategories: toolboxItems.Category[] = []): toolboxItems.Category {

  // There are 25 blocks.
  const contents: toolboxItems.ContentsType[] = [
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myLEDPattern"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "constructor", "returnType": "wpilib.LEDPattern", "args": [{"name": "impl", "type": "Callable[[wpilib._wpilib.LEDPattern.LEDReader, Callable[[int, wpilib._wpilib.Color], None]], None]"}], "tooltip": "", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myCallable"}}}}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "lEDPattern", "type": "wpilib.LEDPattern"}, {"name": "reader", "type": "wpilib.LEDPattern.LEDReader"}, {"name": "writer", "type": "Callable[[int, wpilib._wpilib.Color], None]"}], "tooltip": "", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "applyTo"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myLEDPattern"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myLEDReader"}}}}, "ARG2": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myCallable"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "lEDPattern", "type": "wpilib.LEDPattern"}, {"name": "data", "type": "List[wpilib._wpilib.AddressableLED.LEDData]"}, {"name": "writer", "type": "Callable[[int, wpilib._wpilib.Color], None]"}], "tooltip": "Writes the pattern to an LED buffer. Dynamic animations should be called\nperiodically (such as with a command or with a periodic method) to refresh\nthe buffer over time.\n\nThis method is intentionally designed to use separate objects for reading\nand writing data. By splitting them up, we can easily modify the behavior\nof some base pattern to make it scroll, blink, or breathe by intercepting\nthe data writes to transform their behavior to whatever we like.\n\n:param data:   the current data of the LED strip\n:param writer: data writer for setting new LED colors on the LED strip", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "applyTo"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myLEDPattern"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myList"}}}}, "ARG2": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myCallable"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "lEDPattern", "type": "wpilib.LEDPattern"}, {"name": "data", "type": "List[wpilib._wpilib.AddressableLED.LEDData]"}], "tooltip": "Writes the pattern to an LED buffer. Dynamic animations should be called\nperiodically (such as with a command or with a periodic method) to refresh\nthe buffer over time.\n\nThis method is intentionally designed to use separate objects for reading\nand writing data. By splitting them up, we can easily modify the behavior\nof some base pattern to make it scroll, blink, or breathe by intercepting\nthe data writes to transform their behavior to whatever we like.\n\n:param data: the current data of the LED strip", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "applyTo"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myLEDPattern"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myList"}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myLEDPattern"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpilib.LEDPattern", "args": [{"name": "lEDPattern", "type": "wpilib.LEDPattern"}, {"name": "relativeBrightness", "type": "float"}], "tooltip": "Creates a pattern that plays this one, but at a different brightness.\nBrightness multipliers are applied per-channel in the RGB space; no HSL or\nHSV conversions are applied. Multipliers are also uncapped, which may\nresult in the original colors washing out and appearing less saturated or\neven just a bright white.\n\nThis method is predominantly intended for dimming LEDs to avoid\npainfully bright or distracting patterns from playing (apologies to the\n2024 NE Greater Boston field staff).\n\nFor example, dimming can be done simply by adding a call to\n`atBrightness` at the end of a pattern:\n\n::\n\n    // Solid red, but at 50% brightness\n    frc::LEDPattern::Solid(frc::Color::kRed).AtBrightness(0.5);\n  \n    // Solid white, but at only 10% (i.e. ~0.5V)\n    frc::LEDPattern::Solid(frc:Color::kWhite).AtBrightness(0.1);\n\n:param relativeBrightness: the multiplier to apply to all channels to modify\n                           brightness\n\n:returns: the input pattern, displayed at", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "atBrightness"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myLEDPattern"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myLEDPattern"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpilib.LEDPattern", "args": [{"name": "lEDPattern", "type": "wpilib.LEDPattern"}, {"name": "other", "type": "wpilib.LEDPattern"}], "tooltip": "Creates a pattern that displays outputs as a combination of this pattern\nand another. Color values are calculated as the average color of both\npatterns; if both patterns set the same LED to the same color, then it is\nset to that color, but if one pattern sets to one color and the other\npattern sets it to off, then it will show the color of the first pattern\nbut at approximately half brightness. This is different from {@link\nLEDPattern::OverlayOn(const LEDPattern&)}, which will show the base pattern\nat full brightness if the overlay is set to off at that position.\n\n:param other: the pattern to blend with\n\n:returns: the blended pattern", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "blend"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myLEDPattern"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myLEDPattern"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myLEDPattern"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpilib.LEDPattern", "args": [{"name": "lEDPattern", "type": "wpilib.LEDPattern"}, {"name": "onTime", "type": "wpimath.units.seconds"}, {"name": "offTime", "type": "wpimath.units.seconds"}], "tooltip": "Creates a pattern that switches between playing this pattern and turning\nthe entire LED strip off.\n\n:param onTime:  how long the pattern should play for, per cycle\n:param offTime: how long the pattern should be turned off for, per cycle\n\n:returns: the blinking pattern", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "blink"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myLEDPattern"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myLEDPattern"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpilib.LEDPattern", "args": [{"name": "lEDPattern", "type": "wpilib.LEDPattern"}, {"name": "onTime", "type": "wpimath.units.seconds"}], "tooltip": "Like {@link LEDPattern::Blink(units::second_t)}, but where the\n\"off\" time is exactly equal to the \"on\" time.\n\n:param onTime: how long the pattern should play for (and be turned off for),\n               per cycle\n\n:returns: the blinking pattern", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "blink"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myLEDPattern"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myLEDPattern"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpilib.LEDPattern", "args": [{"name": "lEDPattern", "type": "wpilib.LEDPattern"}, {"name": "period", "type": "wpimath.units.seconds"}], "tooltip": "Creates a pattern that brightens and dims this one over time. Brightness\nfollows a sinusoidal pattern.\n\n:param period: how fast the breathing pattern should complete a single cycle\n\n:returns: the breathing pattern", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "breathe"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myLEDPattern"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myLEDPattern"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "static", "returnType": "wpilib.LEDPattern", "args": [{"name": "type", "type": "wpilib.LEDPattern.GradientType"}, {"name": "colors", "type": "List[wpilib._wpilib.Color]"}], "tooltip": "Creates a pattern that displays a non-animated gradient of colors across\nthe entire length of the LED strip. Colors are evenly distributed along the\nfull length of the LED strip. The gradient type is configured with the\n``type`` parameter, allowing the gradient to be either continuous (no\nseams, good for scrolling effects) or discontinuous (a clear seam is\nvisible, but the gradient applies to the full length of the LED strip\nwithout needing to use some space for wrapping).\n\n:param type:   the type of gradient (continuous or discontinuous)\n:param colors: the colors to display in the gradient\n\n:returns: a motionless gradient pattern", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "gradient"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myGradientType"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myList"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myLEDPattern"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpilib.LEDPattern", "args": [{"name": "lEDPattern", "type": "wpilib.LEDPattern"}, {"name": "indexMapper", "type": "Callable[[int, int], int]"}], "tooltip": "Creates a pattern with remapped indices.\n\n:param indexMapper: the index mapper\n\n:returns: the mapped pattern", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "mapIndex"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myLEDPattern"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myCallable"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myLEDPattern"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpilib.LEDPattern", "args": [{"name": "lEDPattern", "type": "wpilib.LEDPattern"}, {"name": "mask", "type": "wpilib.LEDPattern"}], "tooltip": "Similar to {@link LEDPattern::Blend(const LEDPattern&)}, but performs a\nbitwise mask on each color channel rather than averaging the colors for\neach LED. This can be helpful for displaying only a portion of the base\npattern by applying a mask that sets the desired area to white, and all\nother areas to black. However, it can also be used to display only certain\ncolor channels or hues; for example, masking with {@code\nLEDPattern.color(Color.kRed)} will turn off the green and blue channels on\nthe output pattern, leaving only the red LEDs to be illuminated.\n\n:param mask: the mask to apply\n\n:returns: the masked pattern", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "mask"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myLEDPattern"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myLEDPattern"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myLEDPattern"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "static", "returnType": "wpilib.LEDPattern", "args": [], "tooltip": "A pattern that turns off all LEDs.", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "off"}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myLEDPattern"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpilib.LEDPattern", "args": [{"name": "lEDPattern", "type": "wpilib.LEDPattern"}, {"name": "offset", "type": "int"}], "tooltip": "Creates a pattern that displays this one, but offset by a certain number of\nLEDs. The offset pattern will wrap around, if necessary.\n\n:param offset: how many LEDs to offset by\n\n:returns: the offset pattern", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "offsetBy"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myLEDPattern"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myLEDPattern"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpilib.LEDPattern", "args": [{"name": "lEDPattern", "type": "wpilib.LEDPattern"}, {"name": "base", "type": "wpilib.LEDPattern"}], "tooltip": "Creates a pattern that plays this pattern overlaid on another. Anywhere\nthis pattern sets an LED to off (or {@link frc::Color::kBlack}), the base\npattern will be displayed instead.\n\n:param base: the base pattern to overlay on top of\n\n:returns: the combined overlay pattern", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "overlayOn"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myLEDPattern"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myLEDPattern"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myLEDPattern"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "static", "returnType": "wpilib.LEDPattern", "args": [{"name": "progressFunction", "type": "Callable[[], float]"}], "tooltip": "Creates a pattern that works as a mask layer for {@link\nLEDPattern::Mask(const LEDPattern&)} that illuminates only the portion of\nthe LED strip corresponding with some progress. The mask pattern will start\nfrom the base and set LEDs to white at a proportion equal to the progress\nreturned by the function. Some usages for this could be for displaying\nprogress of a flywheel to its target velocity, progress of a complex\nautonomous sequence, or the height of an elevator.\n\nFor example, creating a mask for displaying a red-to-blue gradient,\nstarting from the red end, based on where an elevator is in its range of\ntravel.\n\n::\n\n  frc::LEDPattern basePattern =\n    frc::LEDPattern::Gradient(frc::Color::kRed, frc::Color::kBlue);\n  frc::LEDPattern progressPattern =\n    basePattern.Mask(frc::LEDPattern::ProgressMaskLayer([&]() {\n      return elevator.GetHeight() / elevator.MaxHeight();\n    });\n\n:param progressFunction: the function to call to determine the progress.\n                         This should return values in the range [0, 1]; any values outside that\n                         range will be clamped.\n\n:returns: the mask pattern", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "progressMaskLayer"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myCallable"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myLEDPattern"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "static", "returnType": "wpilib.LEDPattern", "args": [{"name": "saturation", "type": "int"}, {"name": "value", "type": "int"}], "tooltip": "Creates an LED pattern that displays a rainbow across the color wheel. The\nrainbow pattern will stretch across the entire length of the LED strip.\n\n:param saturation: the saturation of the HSV colors, in [0, 255]\n:param value:      the value of the HSV colors, in [0, 255]\n\n:returns: the rainbow pattern", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "rainbow"}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myLEDPattern"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpilib.LEDPattern", "args": [{"name": "lEDPattern", "type": "wpilib.LEDPattern"}], "tooltip": "Creates a pattern that displays this one in reverse. Scrolling patterns\nwill scroll in the opposite direction (but at the same speed). It will\ntreat the end of an LED strip as the start, and the start of the strip as\nthe end. This can be useful for making ping-pong patterns that travel from\none end of an LED strip to the other, then reverse direction and move back\nto the start. This can also be useful when working with LED strips\nconnected in a serpentine pattern (where the start of one strip is\nconnected to the end of the previous one).\n\n:returns: the reverse pattern", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "reversed"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myLEDPattern"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myLEDPattern"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpilib.LEDPattern", "args": [{"name": "lEDPattern", "type": "wpilib.LEDPattern"}, {"name": "velocity", "type": "wpimath.units.meters_per_second"}, {"name": "ledSpacing", "type": "wpimath.units.meters"}], "tooltip": "Creates a pattern that plays this one scrolling up an LED strip. A negative\nvelocity makes the pattern play in reverse.\n\nFor example, scrolling a pattern at 4 inches per second along an LED\nstrip with 60 LEDs per meter:\n\n::\n\n    // LEDs per meter, a known value taken from the spec sheet of our\n  particular LED strip units::meter_t LED_SPACING = units::meter_t{1 /60.0};\n  \n    frc::LEDPattern rainbow = frc::LEDPattern::Rainbow();\n    frc::LEDPattern scrollingRainbow =\n      rainbow.ScrollAtAbsoluteSpeed(units::feet_per_second_t{1 / 3.0},\n  LED_SPACING);\n\nNote that this pattern will scroll *faster* if applied to a less\ndense LED strip (such as 30 LEDs per meter), or *slower* if applied to\na denser LED strip (such as 120 or 144 LEDs per meter).\n\n:param velocity:   how fast the pattern should move along a physical LED strip\n:param ledSpacing: the distance between adjacent LEDs on the physical LED\n                   strip\n\n:returns: the scrolling pattern", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "scrollAtAbsoluteSpeed"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myLEDPattern"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myLEDPattern"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpilib.LEDPattern", "args": [{"name": "lEDPattern", "type": "wpilib.LEDPattern"}, {"name": "velocity", "type": "wpimath.units.hertz"}], "tooltip": "Creates a pattern that plays this one scrolling up the buffer. The velocity\ncontrols how fast the pattern returns back to its original position, and is\nin terms of the length of the LED strip; scrolling across a segment that is\n10 LEDs long will travel twice as fast as on a segment that's only 5 LEDs\nlong (assuming equal LED density on both segments).", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "scrollAtRelativeSpeed"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myLEDPattern"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myLEDPattern"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "static", "returnType": "wpilib.LEDPattern", "args": [{"name": "color", "type": "wpilib.Color"}], "tooltip": "Creates a pattern that displays a single static color along the entire\nlength of the LED strip.\n\n:param color: the color to display\n\n:returns: the pattern", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "solid"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myColor"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myLEDPattern"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "static", "returnType": "wpilib.LEDPattern", "args": [{"name": "steps", "type": "List[tuple[float, wpilib._wpilib.Color]]"}], "tooltip": "Display a set of colors in steps across the length of the LED strip. No\ninterpolation is done between colors. Colors are specified by the first LED\non the strip to show that color. The last color in the map will be\ndisplayed all the way to the end of the strip. LEDs positioned before the\nfirst specified step will be turned off (you can think of this as if\nthere's a 0 -> black step by default).\n\n:param steps: a map of progress to the color to start displaying at that\n              position along the LED strip\n\n:returns: a motionless step pattern", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "steps"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myList"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myLEDPattern"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpilib.LEDPattern", "args": [{"name": "lEDPattern", "type": "wpilib.LEDPattern"}, {"name": "signal", "type": "Callable[[], bool]"}], "tooltip": "Creates a pattern that blinks this one on and off in sync with a true/false\nsignal. The pattern will play while the signal outputs ``true``, and\nwill turn off while the signal outputs\n``false``.\n\n:param signal: the signal to synchronize with\n\n:returns: the blinking pattern", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.LEDPattern", "FUNC": "synchronizedBlink"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myLEDPattern"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myCallable"}}}}}}}}},
    {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "wpilib.LEDPattern.GradientType", "importModule": "wpilib"}, "fields": {"ENUM_TYPE": "wpilib.LEDPattern.GradientType", "ENUM_VALUE": "kContinuous"}},
    {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "wpilib.LEDPattern.GradientType", "importModule": "wpilib"}, "fields": {"ENUM_TYPE": "wpilib.LEDPattern.GradientType", "ENUM_VALUE": "kDiscontinuous"}},
  ];

  contents.push(...subcategories);

  const category: toolboxItems.PythonClassCategory = {
    kind: "category",
    name:  "LEDPattern",
    contents: contents,
    className: "wpilib.LEDPattern",
  };

  return category;
}
