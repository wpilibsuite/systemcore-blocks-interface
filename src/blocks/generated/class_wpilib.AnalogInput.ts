// This file was generated. Do not edit!

import * as getPythonVariable from "../mrc_get_python_variable";
import * as toolboxItems from "../../toolbox/items";

// Blocks for class wpilib.AnalogInput

export function initialize() {
  getPythonVariable.initializeClassVariableGetter("wpilib.AnalogInput", "int", ["kAccumulatorModuleNumber", "kAccumulatorNumChannels"], []);
}

export function getToolboxCategory(subcategories: toolboxItems.Category[] = []): toolboxItems.Category {

  // There are 27 blocks.
  const contents: toolboxItems.ContentsType[] = [
    {"kind": "block", "type": "mrc_get_python_variable", "extraState": {"varKind": "class", "moduleOrClassName": "wpilib.AnalogInput", "varType": "int", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "VAR": "kAccumulatorModuleNumber"}},
    {"kind": "block", "type": "mrc_get_python_variable", "extraState": {"varKind": "class", "moduleOrClassName": "wpilib.AnalogInput", "varType": "int", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "VAR": "kAccumulatorNumChannels"}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myAnalogInput"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "constructor", "returnType": "wpilib.AnalogInput", "args": [{"name": "channel", "type": "int"}], "tooltip": "Construct an analog input.\n\n:param channel: The channel number on the roboRIO to represent. 0-3 are\n                on-board 4-7 are on the MXP port.", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput"}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "int", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}], "tooltip": "Read the number of accumulated values.\n\nRead the count of the accumulated values since the accumulator was last\nReset().\n\n:returns: The number of times samples from the channel were accumulated.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "getAccumulatorCount"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "tuple[int, int]", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}], "tooltip": "Read the accumulated value and the number of accumulated values atomically.\n\nThis function reads the value and count from the FPGA atomically.\nThis can be used for averaging.\n\n:param value: Reference to the 64-bit accumulated output.\n:param count: Reference to the number of accumulation cycles.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "getAccumulatorOutput"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "int", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}], "tooltip": "Read the accumulated value.\n\nRead the value that has been accumulating.\nThe accumulator is attached after the oversample and average engine.\n\n:returns: The 64-bit value accumulated since the last Reset().", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "getAccumulatorValue"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "int", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}], "tooltip": "Get the number of averaging bits previously configured.\n\nThis gets the number of averaging bits from the FPGA. The actual number of\naveraged samples is 2^bits. The averaging is done automatically in the\nFPGA.\n\n:returns: Number of bits of averaging previously configured.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "getAverageBits"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "int", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}], "tooltip": "Get a sample from the output of the oversample and average engine for this\nchannel.\n\nThe sample is 12-bit + the bits configured in SetOversampleBits().\nThe value configured in SetAverageBits() will cause this value to be\naveraged 2**bits number of samples.\n\nThis is not a sliding window. The sample will not change until\n2**(OversampleBits + AverageBits) samples have been acquired from the\nmodule on this channel.\n\nUse GetAverageVoltage() to get the analog value in calibrated units.\n\n:returns: A sample from the oversample and average engine for this channel.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "getAverageValue"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "float", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}], "tooltip": "Get a scaled sample from the output of the oversample and average engine\nfor this channel.\n\nThe value is scaled to units of Volts using the calibrated scaling data\nfrom GetLSBWeight() and GetOffset().\n\nUsing oversampling will cause this value to be higher resolution, but it\nwill update more slowly.\n\nUsing averaging will cause this value to be more stable, but it will update\nmore slowly.\n\n:returns: A scaled sample from the output of the oversample and average\n          engine for this channel.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "getAverageVoltage"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "int", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}], "tooltip": "Get the channel number.\n\n:returns: The channel number.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "getChannel"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "int", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}], "tooltip": "Get the factory scaling least significant bit weight constant.\n\nVolts = ((LSB_Weight * 1e-9) * raw) - (Offset * 1e-9)\n\n:returns: Least significant bit weight.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "getLSBWeight"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "int", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}], "tooltip": "Get the factory scaling offset constant.\n\nVolts = ((LSB_Weight * 1e-9) * raw) - (Offset * 1e-9)\n\n:returns: Offset constant.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "getOffset"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "int", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}], "tooltip": "Get the number of oversample bits previously configured.\n\nThis gets the number of oversample bits from the FPGA. The actual number of\noversampled values is 2^bits. The oversampling is done automatically in the\nFPGA.\n\n:returns: Number of bits of oversampling previously configured.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "getOversampleBits"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "static", "returnType": "float", "args": [], "tooltip": "Get the current sample rate for all channels\n\n:returns: Sample rate.", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "getSampleRate"}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "int", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}], "tooltip": "Get a sample straight from this channel.\n\nThe sample is a 12-bit value representing the 0V to 5V range of the A/D\nconverter in the module.  The units are in A/D converter codes.  Use\nGetVoltage() to get the analog value in calibrated units.\n\n:returns: A sample straight from this channel.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "getValue"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "float", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}], "tooltip": "Get a scaled sample straight from this channel.\n\nThe value is scaled to units of Volts using the calibrated scaling data\nfrom GetLSBWeight() and GetOffset().\n\n:returns: A scaled sample straight from this channel.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "getVoltage"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}], "tooltip": "Initialize the accumulator.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "initAccumulator"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}, {"name": "builder", "type": "wpiutil.SendableBuilder"}], "tooltip": "", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "initSendable"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySendableBuilder"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "bool", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}], "tooltip": "Is the channel attached to an accumulator.\n\n:returns: The analog input is attached to an accumulator.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "isAccumulatorChannel"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}], "tooltip": "Resets the accumulator to the initial value.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "resetAccumulator"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}, {"name": "center", "type": "int"}], "tooltip": "Set the center value of the accumulator.\n\nThe center value is subtracted from each A/D value before it is added to\nthe accumulator. This is used for the center value of devices like gyros\nand accelerometers to take the device offset into account when integrating.\n\nThis center value is based on the output of the oversampled and averaged\nsource from the accumulator channel. Because of this, any non-zero\noversample bits will affect the size of the value for this field.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "setAccumulatorCenter"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}, {"name": "deadband", "type": "int"}], "tooltip": "Set the accumulator's deadband.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "setAccumulatorDeadband"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}, {"name": "value", "type": "int"}], "tooltip": "Set an initial value for the accumulator.\n\nThis will be added to all values returned to the user.\n\n:param value: The value that the accumulator should start from when reset.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "setAccumulatorInitialValue"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}, {"name": "bits", "type": "int"}], "tooltip": "Set the number of averaging bits.\n\nThis sets the number of averaging bits. The actual number of averaged\nsamples is 2^bits.\n\nUse averaging to improve the stability of your measurement at the expense\nof sampling rate. The averaging is done automatically in the FPGA.\n\n:param bits: Number of bits of averaging.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "setAverageBits"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}, {"name": "bits", "type": "int"}], "tooltip": "Set the number of oversample bits.\n\nThis sets the number of oversample bits. The actual number of oversampled\nvalues is 2^bits. Use oversampling to improve the resolution of your\nmeasurements at the expense of sampling rate. The oversampling is done\nautomatically in the FPGA.\n\n:param bits: Number of bits of oversampling.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "setOversampleBits"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "static", "returnType": "None", "args": [{"name": "samplesPerSecond", "type": "float"}], "tooltip": "Set the sample rate per channel for all analog channels.\n\nThe maximum rate is 500kS/s divided by the number of channels in use.\nThis is 62500 samples/s per channel.\n\n:param samplesPerSecond: The number of samples per second.", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "setSampleRate"}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "analogInput", "type": "wpilib.AnalogInput"}, {"name": "device", "type": "int"}], "tooltip": "Indicates this input is used by a simulated device.\n\n:param device: simulated device handle", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogInput", "FUNC": "setSimDevice"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}},
  ];

  contents.push(...subcategories);

  const category: toolboxItems.PythonClassCategory = {
    kind: "category",
    name:  "AnalogInput",
    contents: contents,
    className: "wpilib.AnalogInput",
  };

  return category;
}
