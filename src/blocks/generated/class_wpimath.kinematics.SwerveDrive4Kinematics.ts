// This file was generated. Do not edit!

import * as toolboxItems from "../../toolbox/items";

// Blocks for class wpimath.kinematics.SwerveDrive4Kinematics

export function initialize() {
}

export function getToolboxCategory(subcategories: toolboxItems.Category[] = []): toolboxItems.Category {

  // There are 11 blocks.
  const contents: toolboxItems.ContentsType[] = [
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "mySwerveDrive4Kinematics"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "constructor", "returnType": "wpimath.kinematics.SwerveDrive4Kinematics", "args": [{"name": "arg0", "type": "wpimath.geometry.Translation2d"}, {"name": "arg1", "type": "wpimath.geometry.Translation2d"}, {"name": "arg2", "type": "wpimath.geometry.Translation2d"}, {"name": "arg3", "type": "wpimath.geometry.Translation2d"}], "tooltip": "", "importModule": "wpimath.kinematics"}, "fields": {"MODULE_OR_CLASS": "wpimath.kinematics.SwerveDrive4Kinematics"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTranslation2d"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTranslation2d"}}}}, "ARG2": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTranslation2d"}}}}, "ARG3": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTranslation2d"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "static", "returnType": "Tuple[wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState]", "args": [{"name": "moduleStates", "type": "Tuple[wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState]"}, {"name": "attainableMaxSpeed", "type": "wpimath.units.meters_per_second"}], "tooltip": "Renormalizes the wheel speeds if any individual speed is above the\nspecified maximum.\n\nSometimes, after inverse kinematics, the requested speed\nfrom one or more modules may be above the max attainable speed for the\ndriving motor on that module. To fix this issue, one can reduce all the\nwheel speeds to make sure that all requested module speeds are at-or-below\nthe absolute threshold, while maintaining the ratio of speeds between\nmodules.\n\n:param moduleStates:       Reference to array of module states. The array will be\n                           mutated with the normalized speeds!\n:param attainableMaxSpeed: The absolute max speed that a module can reach.", "importModule": "wpimath.kinematics"}, "fields": {"MODULE_OR_CLASS": "wpimath.kinematics.SwerveDrive4Kinematics", "FUNC": "desaturateWheelSpeeds"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTuple"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "static", "returnType": "Tuple[wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState]", "args": [{"name": "moduleStates", "type": "Tuple[wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState]"}, {"name": "desiredChassisSpeed", "type": "wpimath.kinematics.ChassisSpeeds"}, {"name": "attainableMaxModuleSpeed", "type": "wpimath.units.meters_per_second"}, {"name": "attainableMaxRobotTranslationSpeed", "type": "wpimath.units.meters_per_second"}, {"name": "attainableMaxRobotRotationSpeed", "type": "wpimath.units.radians_per_second"}], "tooltip": "Renormalizes the wheel speeds if any individual speed is above the\nspecified maximum, as well as getting rid of joystick saturation at edges\nof joystick.\n\nSometimes, after inverse kinematics, the requested speed\nfrom one or more modules may be above the max attainable speed for the\ndriving motor on that module. To fix this issue, one can reduce all the\nwheel speeds to make sure that all requested module speeds are at-or-below\nthe absolute threshold, while maintaining the ratio of speeds between\nmodules.\n\n:param moduleStates:                       Reference to array of module states. The array will be\n                                           mutated with the normalized speeds!\n:param desiredChassisSpeed:                The desired speed of the robot\n:param attainableMaxModuleSpeed:           The absolute max speed a module can reach\n:param attainableMaxRobotTranslationSpeed: The absolute max speed the robot\n                                           can reach while translating\n:param attainableMaxRobotRotationSpeed:    The absolute max speed the robot can\n                                           reach while rotating", "importModule": "wpimath.kinematics"}, "fields": {"MODULE_OR_CLASS": "wpimath.kinematics.SwerveDrive4Kinematics", "FUNC": "desaturateWheelSpeeds"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTuple"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myChassisSpeeds"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "Tuple[wpimath.geometry._geometry.Translation2d, wpimath.geometry._geometry.Translation2d, wpimath.geometry._geometry.Translation2d, wpimath.geometry._geometry.Translation2d]", "args": [{"name": "swerveDrive4Kinematics", "type": "wpimath.kinematics.SwerveDrive4Kinematics"}], "tooltip": "", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpimath.kinematics.SwerveDrive4Kinematics", "FUNC": "getModules"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySwerveDrive4Kinematics"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "Tuple[wpimath.kinematics._kinematics.SwerveModulePosition, wpimath.kinematics._kinematics.SwerveModulePosition, wpimath.kinematics._kinematics.SwerveModulePosition, wpimath.kinematics._kinematics.SwerveModulePosition]", "args": [{"name": "swerveDrive4Kinematics", "type": "wpimath.kinematics.SwerveDrive4Kinematics"}, {"name": "start", "type": "Tuple[wpimath.kinematics._kinematics.SwerveModulePosition, wpimath.kinematics._kinematics.SwerveModulePosition, wpimath.kinematics._kinematics.SwerveModulePosition, wpimath.kinematics._kinematics.SwerveModulePosition]"}, {"name": "end", "type": "Tuple[wpimath.kinematics._kinematics.SwerveModulePosition, wpimath.kinematics._kinematics.SwerveModulePosition, wpimath.kinematics._kinematics.SwerveModulePosition, wpimath.kinematics._kinematics.SwerveModulePosition]"}, {"name": "t", "type": "float"}], "tooltip": "", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpimath.kinematics.SwerveDrive4Kinematics", "FUNC": "interpolate"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySwerveDrive4Kinematics"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTuple"}}}}, "ARG2": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTuple"}}}}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "swerveDrive4Kinematics", "type": "wpimath.kinematics.SwerveDrive4Kinematics"}, {"name": "moduleHeadings", "type": "Tuple[wpimath.geometry._geometry.Rotation2d, wpimath.geometry._geometry.Rotation2d, wpimath.geometry._geometry.Rotation2d, wpimath.geometry._geometry.Rotation2d]"}], "tooltip": "Reset the internal swerve module headings.\n\n:param moduleHeadings: The swerve module headings. The order of the module\n                       headings should be same as passed into the constructor of this class.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpimath.kinematics.SwerveDrive4Kinematics", "FUNC": "resetHeadings"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySwerveDrive4Kinematics"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTuple"}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myChassisSpeeds"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpimath.kinematics.ChassisSpeeds", "args": [{"name": "swerveDrive4Kinematics", "type": "wpimath.kinematics.SwerveDrive4Kinematics"}, {"name": "moduleStates", "type": "Tuple[wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState]"}], "tooltip": "Performs forward kinematics to return the resulting chassis state from the\ngiven module states. This method is often used for odometry -- determining\nthe robot's position on the field using data from the real-world speed and\nangle of each module on the robot.\n\n:param moduleStates: The state of the modules as an wpi::array of type\n                     SwerveModuleState, NumModules long as measured from respective encoders\n                     and gyros. The order of the swerve module states should be same as passed\n                     into the constructor of this class.\n\n:returns: The resulting chassis speed.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpimath.kinematics.SwerveDrive4Kinematics", "FUNC": "toChassisSpeeds"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySwerveDrive4Kinematics"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTuple"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "Tuple[wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState]", "args": [{"name": "swerveDrive4Kinematics", "type": "wpimath.kinematics.SwerveDrive4Kinematics"}, {"name": "chassisSpeeds", "type": "wpimath.kinematics.ChassisSpeeds"}, {"name": "centerOfRotation", "type": "wpimath.geometry.Translation2d"}], "tooltip": "Performs inverse kinematics to return the module states from a desired\nchassis velocity. This method is often used to convert joystick values into\nmodule speeds and angles.\n\nThis function also supports variable centers of rotation. During normal\noperations, the center of rotation is usually the same as the physical\ncenter of the robot; therefore, the argument is defaulted to that use case.\nHowever, if you wish to change the center of rotation for evasive\nmaneuvers, vision alignment, or for any other use case, you can do so.\n\n:param chassisSpeeds:    The desired chassis speed.\n:param centerOfRotation: The center of rotation. For example, if you set the\n center of rotation at one corner of the robot and provide a chassis speed\n that only has a dtheta component, the robot will rotate around that corner.\n\n:returns: An array containing the module states. Use caution because these\n          module states are not normalized. Sometimes, a user input may cause one of\n          the module speeds to go above the attainable max velocity. Use the\n          :meth:`desaturateWheelSpeeds` function to rectify this issue.\n          In addition, you can use Python unpacking syntax\n          to directly assign the module states to variables::\n\n            fl, fr, bl, br = kinematics.toSwerveModuleStates(chassisSpeeds)", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpimath.kinematics.SwerveDrive4Kinematics", "FUNC": "toSwerveModuleStates"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySwerveDrive4Kinematics"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myChassisSpeeds"}}}}, "ARG2": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTranslation2d"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTwist2d"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpimath.geometry.Twist2d", "args": [{"name": "swerveDrive4Kinematics", "type": "wpimath.kinematics.SwerveDrive4Kinematics"}, {"name": "moduleDeltas", "type": "Tuple[wpimath.kinematics._kinematics.SwerveModulePosition, wpimath.kinematics._kinematics.SwerveModulePosition, wpimath.kinematics._kinematics.SwerveModulePosition, wpimath.kinematics._kinematics.SwerveModulePosition]"}], "tooltip": "Performs forward kinematics to return the resulting Twist2d from the\ngiven module position deltas. This method is often used for odometry --\ndetermining the robot's position on the field using data from the\nreal-world position delta and angle of each module on the robot.\n\n:param moduleDeltas: The latest change in position of the modules (as a\n                     SwerveModulePosition type) as measured from respective encoders and gyros.\n                     The order of the swerve module states should be same as passed into the\n                     constructor of this class.\n\n:returns: The resulting Twist2d.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpimath.kinematics.SwerveDrive4Kinematics", "FUNC": "toTwist2d"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySwerveDrive4Kinematics"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTuple"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTwist2d"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpimath.geometry.Twist2d", "args": [{"name": "swerveDrive4Kinematics", "type": "wpimath.kinematics.SwerveDrive4Kinematics"}, {"name": "start", "type": "Tuple[wpimath.kinematics._kinematics.SwerveModulePosition, wpimath.kinematics._kinematics.SwerveModulePosition, wpimath.kinematics._kinematics.SwerveModulePosition, wpimath.kinematics._kinematics.SwerveModulePosition]"}, {"name": "end", "type": "Tuple[wpimath.kinematics._kinematics.SwerveModulePosition, wpimath.kinematics._kinematics.SwerveModulePosition, wpimath.kinematics._kinematics.SwerveModulePosition, wpimath.kinematics._kinematics.SwerveModulePosition]"}], "tooltip": "", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpimath.kinematics.SwerveDrive4Kinematics", "FUNC": "toTwist2d"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySwerveDrive4Kinematics"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTuple"}}}}, "ARG2": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTuple"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "Tuple[wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState, wpimath.kinematics._kinematics.SwerveModuleState]", "args": [{"name": "swerveDrive4Kinematics", "type": "wpimath.kinematics.SwerveDrive4Kinematics"}, {"name": "chassisSpeeds", "type": "wpimath.kinematics.ChassisSpeeds"}], "tooltip": "", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpimath.kinematics.SwerveDrive4Kinematics", "FUNC": "toWheelSpeeds"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySwerveDrive4Kinematics"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myChassisSpeeds"}}}}}}}}},
  ];

  contents.push(...subcategories);

  const category: toolboxItems.PythonClassCategory = {
    kind: "category",
    name:  "SwerveDrive4Kinematics",
    contents: contents,
    className: "wpimath.kinematics.SwerveDrive4Kinematics",
  };

  return category;
}
