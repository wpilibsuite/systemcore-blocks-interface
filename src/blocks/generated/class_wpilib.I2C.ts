// This file was generated. Do not edit!

import * as pythonEnum from "../mrc_get_python_enum_value";
import * as toolboxItems from "../../toolbox/items";

// Blocks for class wpilib.I2C

export function initialize() {
  pythonEnum.initializeEnum("wpilib.I2C.Port", ["kMXP", "kOnboard"], "I2C connection ports.\n\nMembers:\n\n  kOnboard : Onboard I2C port.\n\n  kMXP : MXP (roboRIO MXP) I2C port.");
}

export function getToolboxCategory(subcategories: toolboxItems.Category[] = []): toolboxItems.Category {

  // There are 12 blocks.
  const contents: toolboxItems.ContentsType[] = [
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myI2C"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "constructor", "returnType": "wpilib.I2C", "args": [{"name": "port", "type": "wpilib.I2C.Port"}, {"name": "deviceAddress", "type": "int"}], "tooltip": "Constructor.\n\n:param port:          The I2C port to which the device is connected.\n:param deviceAddress: The address of the device on the I2C bus.", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.I2C"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myPort"}}}}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "bool", "args": [{"name": "i2C", "type": "wpilib.I2C"}], "tooltip": "Attempt to address a device on the I2C bus.\n\nThis allows you to figure out if there is a device on the I2C bus that\nresponds to the address specified in the constructor.\n\n:returns: Transfer Aborted... false for success, true for aborted.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.I2C", "FUNC": "addressOnly"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myI2C"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "int", "args": [{"name": "i2C", "type": "wpilib.I2C"}], "tooltip": "Returns I2C device address.\n\n:returns: I2C device address.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.I2C", "FUNC": "getDeviceAddress"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myI2C"}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myPort"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpilib.I2C.Port", "args": [{"name": "i2C", "type": "wpilib.I2C"}], "tooltip": "Returns I2C port.\n\n:returns: I2C port.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.I2C", "FUNC": "getPort"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myI2C"}}}}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "bool", "args": [{"name": "i2C", "type": "wpilib.I2C"}, {"name": "registerAddress", "type": "int"}, {"name": "data", "type": "Buffer"}], "tooltip": "Execute a read transaction with the device.\n\nRead bytes from a device.\nMost I2C devices will auto-increment the register pointer internally\nallowing you to read consecutive registers on a device in a single\ntransaction.\n\n:param registerAddress: The register to read first in the transaction.\n:param count:           The number of bytes to read in the transaction.\n:param data:            A pointer to the array of bytes to store the data\n                        read from the device.\n\n:returns: Transfer Aborted... false for success, true for aborted.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.I2C", "FUNC": "read"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myI2C"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "bool", "args": [{"name": "i2C", "type": "wpilib.I2C"}, {"name": "buffer", "type": "Buffer"}], "tooltip": "Execute a read only transaction with the device.\n\nRead bytes from a device. This method does not write any data to prompt the\ndevice.\n\n:param buffer: A pointer to the array of bytes to store the data read from\n               the device.\n:param count:  The number of bytes to read in the transaction.\n\n:returns: Transfer Aborted... false for success, true for aborted.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.I2C", "FUNC": "readOnly"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myI2C"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "bool", "args": [{"name": "i2C", "type": "wpilib.I2C"}, {"name": "dataToSend", "type": "Buffer"}, {"name": "dataReceived", "type": "Buffer"}], "tooltip": "Generic transaction.\n\nThis is a lower-level interface to the I2C hardware giving you more control\nover each transaction. If you intend to write multiple bytes in the same\ntransaction and do not plan to receive anything back, use writeBulk()\ninstead. Calling this with a receiveSize of 0 will result in an error.\n\n:param dataToSend:   Buffer of data to send as part of the transaction.\n:param sendSize:     Number of bytes to send as part of the transaction.\n:param dataReceived: Buffer to read data into.\n:param receiveSize:  Number of bytes to read from the device.\n\n:returns: Transfer Aborted... false for success, true for aborted.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.I2C", "FUNC": "transaction"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myI2C"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "bool", "args": [{"name": "i2C", "type": "wpilib.I2C"}, {"name": "registerAddress", "type": "int"}, {"name": "expected", "type": "Buffer"}], "tooltip": "Verify that a device's registers contain expected values.\n\nMost devices will have a set of registers that contain a known value that\ncan be used to identify them.  This allows an I2C device driver to easily\nverify that the device contains the expected value.\n\n@pre The device must support and be configured to use register\nauto-increment.\n\n:param registerAddress: The base register to start reading from the device.\n:param count:           The size of the field to be verified.\n:param expected:        A buffer containing the values expected from the\n                        device.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.I2C", "FUNC": "verifySensor"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myI2C"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "bool", "args": [{"name": "i2C", "type": "wpilib.I2C"}, {"name": "registerAddress", "type": "int"}, {"name": "data", "type": "int"}], "tooltip": "Execute a write transaction with the device.\n\nWrite a single byte to a register on a device and wait until the\ntransaction is complete.\n\n:param registerAddress: The address of the register on the device to be\n                        written.\n:param data:            The byte to write to the register on the device.\n\n:returns: Transfer Aborted... false for success, true for aborted.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.I2C", "FUNC": "write"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myI2C"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "bool", "args": [{"name": "i2C", "type": "wpilib.I2C"}, {"name": "data", "type": "Buffer"}], "tooltip": "Execute a bulk write transaction with the device.\n\nWrite multiple bytes to a device and wait until the\ntransaction is complete.\n\n:param data:  The data to write to the register on the device.\n:param count: The number of bytes to be written.\n\n:returns: Transfer Aborted... false for success, true for aborted.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.I2C", "FUNC": "writeBulk"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myI2C"}}}}}},
    {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "wpilib.I2C.Port", "importModule": "wpilib"}, "fields": {"ENUM_TYPE": "wpilib.I2C.Port", "ENUM_VALUE": "kMXP"}},
    {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "wpilib.I2C.Port", "importModule": "wpilib"}, "fields": {"ENUM_TYPE": "wpilib.I2C.Port", "ENUM_VALUE": "kOnboard"}},
  ];

  contents.push(...subcategories);

  const category: toolboxItems.PythonClassCategory = {
    kind: "category",
    name:  "I2C",
    contents: contents,
    className: "wpilib.I2C",
  };

  return category;
}
