// This file was generated. Do not edit!

import * as getPythonVariable from "../mrc_get_python_variable";
import * as toolboxItems from "../../toolbox/items";

// Blocks for class wpilib.AnalogGyro

export function initialize() {
  getPythonVariable.initializeClassVariableGetter("wpilib.AnalogGyro", "int", ["kAverageBits", "kOversampleBits"], []);
  getPythonVariable.initializeClassVariableGetter("wpilib.AnalogGyro", "float", ["kCalibrationSampleTime", "kDefaultVoltsPerDegreePerSecond", "kSamplesPerSecond"], []);
}

export function getToolboxCategory(subcategories: toolboxItems.Category[] = []): toolboxItems.Category {

  // There are 21 blocks.
  const contents: toolboxItems.ContentsType[] = [
    {"kind": "block", "type": "mrc_get_python_variable", "extraState": {"varKind": "class", "moduleOrClassName": "wpilib.AnalogGyro", "varType": "int", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro", "VAR": "kAverageBits"}},
    {"kind": "block", "type": "mrc_get_python_variable", "extraState": {"varKind": "class", "moduleOrClassName": "wpilib.AnalogGyro", "varType": "int", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro", "VAR": "kOversampleBits"}},
    {"kind": "block", "type": "mrc_get_python_variable", "extraState": {"varKind": "class", "moduleOrClassName": "wpilib.AnalogGyro", "varType": "float", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro", "VAR": "kCalibrationSampleTime"}},
    {"kind": "block", "type": "mrc_get_python_variable", "extraState": {"varKind": "class", "moduleOrClassName": "wpilib.AnalogGyro", "varType": "float", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro", "VAR": "kDefaultVoltsPerDegreePerSecond"}},
    {"kind": "block", "type": "mrc_get_python_variable", "extraState": {"varKind": "class", "moduleOrClassName": "wpilib.AnalogGyro", "varType": "float", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro", "VAR": "kSamplesPerSecond"}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myAnalogGyro"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "constructor", "returnType": "wpilib.AnalogGyro", "args": [{"name": "channel", "type": "int"}], "tooltip": "%Gyro constructor using the Analog Input channel number.\n\n:param channel: The analog channel the gyro is connected to. Gyros can only\n                be used on on-board Analog Inputs 0-1.", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro"}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myAnalogGyro"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "constructor", "returnType": "wpilib.AnalogGyro", "args": [{"name": "channel", "type": "wpilib.AnalogInput"}], "tooltip": "%Gyro constructor with a precreated AnalogInput object.\n\nUse this constructor when the analog channel needs to be shared.\nThis object will not clean up the AnalogInput object when using this\nconstructor.\n\n:param channel: A pointer to the AnalogInput object that the gyro is\n                connected to.", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myAnalogGyro"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "constructor", "returnType": "wpilib.AnalogGyro", "args": [{"name": "channel", "type": "int"}, {"name": "center", "type": "int"}, {"name": "offset", "type": "float"}], "tooltip": "%Gyro constructor using the Analog Input channel number with parameters for\npresetting the center and offset values. Bypasses calibration.\n\n:param channel: The analog channel the gyro is connected to. Gyros can only\n                be used on on-board Analog Inputs 0-1.\n:param center:  Preset uncalibrated value to use as the accumulator center\n                value.\n:param offset:  Preset uncalibrated value to use as the gyro offset.", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro"}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myAnalogGyro"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "constructor", "returnType": "wpilib.AnalogGyro", "args": [{"name": "channel", "type": "wpilib.AnalogInput"}, {"name": "center", "type": "int"}, {"name": "offset", "type": "float"}], "tooltip": "%Gyro constructor with a precreated AnalogInput object and calibrated\nparameters.\n\nUse this constructor when the analog channel needs to be shared.\nThis object will not clean up the AnalogInput object when using this\nconstructor.\n\n:param channel: A pointer to the AnalogInput object that the gyro is\n                connected to.\n:param center:  Preset uncalibrated value to use as the accumulator center\n                value.\n:param offset:  Preset uncalibrated value to use as the gyro offset.", "importModule": "wpilib"}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogInput"}}}}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "analogGyro", "type": "wpilib.AnalogGyro"}], "tooltip": "Calibrate the gyro by running for a number of samples and computing the\ncenter value. Then use the center value as the Accumulator center value for\nsubsequent measurements.\n\nIt's important to make sure that the robot is not moving while the\ncentering calculations are in progress, this is typically done when the\nrobot is first turned on while it's sitting at rest before the competition\nstarts.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro", "FUNC": "calibrate"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogGyro"}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myAnalogInput"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpilib.AnalogInput", "args": [{"name": "analogGyro", "type": "wpilib.AnalogGyro"}], "tooltip": "Gets the analog input for the gyro.\n\n:returns: AnalogInput", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro", "FUNC": "getAnalogInput"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogGyro"}}}}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "float", "args": [{"name": "analogGyro", "type": "wpilib.AnalogGyro"}], "tooltip": "Return the actual angle in degrees that the robot is currently facing.\n\nThe angle is based on the current accumulator value corrected by the\noversampling rate, the gyro type and the A/D calibration values. The angle\nis continuous, that is it will continue from 360->361 degrees. This allows\nalgorithms that wouldn't want to see a discontinuity in the gyro output as\nit sweeps from 360 to 0 on the second time around.\n\n:returns: The current heading of the robot in degrees. This heading is based\n          on integration of the returned rate from the gyro.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro", "FUNC": "getAngle"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogGyro"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "int", "args": [{"name": "analogGyro", "type": "wpilib.AnalogGyro"}], "tooltip": "Return the gyro center value. If run after calibration,\nthe center value can be used as a preset later.\n\n:returns: the current center value", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro", "FUNC": "getCenter"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogGyro"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "float", "args": [{"name": "analogGyro", "type": "wpilib.AnalogGyro"}], "tooltip": "Return the gyro offset value. If run after calibration,\nthe offset value can be used as a preset later.\n\n:returns: the current offset value", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro", "FUNC": "getOffset"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogGyro"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "float", "args": [{"name": "analogGyro", "type": "wpilib.AnalogGyro"}], "tooltip": "Return the rate of rotation of the gyro\n\nThe rate is based on the most recent reading of the gyro analog value\n\n:returns: the current rate in degrees per second", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro", "FUNC": "getRate"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogGyro"}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myRotation2d"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpimath.geometry.Rotation2d", "args": [{"name": "analogGyro", "type": "wpilib.AnalogGyro"}], "tooltip": "Return the heading of the robot as a Rotation2d.\n\nThe angle is continuous, that is it will continue from 360 to 361 degrees.\nThis allows algorithms that wouldn't want to see a discontinuity in the\ngyro output as it sweeps past from 360 to 0 on the second time around.\n\nThe angle is expected to increase as the gyro turns counterclockwise when\nlooked at from the top. It needs to follow the NWU axis convention.\n\n:returns: the current heading of the robot as a Rotation2d. This heading is\n          based on integration of the returned rate from the gyro.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro", "FUNC": "getRotation2d"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogGyro"}}}}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "analogGyro", "type": "wpilib.AnalogGyro"}], "tooltip": "Initialize the gyro.\n\nCalibration is handled by Calibrate().", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro", "FUNC": "initGyro"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogGyro"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "analogGyro", "type": "wpilib.AnalogGyro"}, {"name": "builder", "type": "wpiutil.SendableBuilder"}], "tooltip": "", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro", "FUNC": "initSendable"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogGyro"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySendableBuilder"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "analogGyro", "type": "wpilib.AnalogGyro"}], "tooltip": "Reset the gyro.\n\nResets the gyro to a heading of zero. This can be used if there is\nsignificant drift in the gyro and it needs to be recalibrated after it has\nbeen running.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro", "FUNC": "reset"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogGyro"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "analogGyro", "type": "wpilib.AnalogGyro"}, {"name": "volts", "type": "float"}], "tooltip": "Set the size of the neutral zone.\n\nAny voltage from the gyro less than this amount from the center is\nconsidered stationary.  Setting a deadband will decrease the amount of\ndrift when the gyro isn't rotating, but will make it less accurate.\n\n:param volts: The size of the deadband in volts", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro", "FUNC": "setDeadband"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogGyro"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "analogGyro", "type": "wpilib.AnalogGyro"}, {"name": "voltsPerDegreePerSecond", "type": "float"}], "tooltip": "Set the gyro sensitivity.\n\nThis takes the number of volts/degree/second sensitivity of the gyro and\nuses it in subsequent calculations to allow the code to work with multiple\ngyros. This value is typically found in the gyro datasheet.\n\n:param voltsPerDegreePerSecond: The sensitivity in Volts/degree/second", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpilib.AnalogGyro", "FUNC": "setSensitivity"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogGyro"}}}}}},
  ];

  contents.push(...subcategories);

  const category: toolboxItems.PythonClassCategory = {
    kind: "category",
    name:  "AnalogGyro",
    contents: contents,
    className: "wpilib.AnalogGyro",
  };

  return category;
}
