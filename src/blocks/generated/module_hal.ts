// This file was generated. Do not edit!

import * as pythonEnum from "../mrc_get_python_enum_value";
import {Category} from "../../toolbox/items";

// Blocks for module hal

export function initialize() {
  pythonEnum.initializeEnum("hal.AccelerometerRange", ["k2G", "k4G", "k8G"], "The acceptable accelerometer ranges.\n\nMembers:\n\n  k2G\n\n  k4G\n\n  k8G");
  pythonEnum.initializeEnum("hal.AllianceStationID", ["kBlue1", "kBlue2", "kBlue3", "kRed1", "kRed2", "kRed3", "kUnknown"], "Members:\n\n  kUnknown : Unknown Alliance Station\n\n  kRed1 : Red Alliance Station 1\n\n  kRed2 : Red Alliance Station 2\n\n  kRed3 : Red Alliance Station 3\n\n  kBlue1 : Blue Alliance Station 1\n\n  kBlue2 : Blue Alliance Station 2\n\n  kBlue3 : Blue Alliance Station 3");
  pythonEnum.initializeEnum("hal.AnalogTriggerType", ["kFallingPulse", "kInWindow", "kRisingPulse", "kState"], "The type of analog trigger to trigger on.\n\nMembers:\n\n  kInWindow\n\n  kState\n\n  kRisingPulse\n\n  kFallingPulse");
  pythonEnum.initializeEnum("hal.CANDeviceType", ["kAccelerometer", "kBroadcast", "kFirmwareUpdate", "kGearToothSensor", "kGyroSensor", "kIOBreakout", "kMiscellaneous", "kMotorController", "kPneumatics", "kPowerDistribution", "kRelayController", "kRobotController", "kServoController", "kUltrasonicSensor"], "The CAN device type.\n\nTeams should use HAL_CAN_Dev_kMiscellaneous\n\nMembers:\n\n  kBroadcast : Broadcast.\n\n  kRobotController : Robot controller.\n\n  kMotorController : Motor controller.\n\n  kRelayController : Relay controller.\n\n  kGyroSensor : Gyro sensor.\n\n  kAccelerometer : Accelerometer.\n\n  kUltrasonicSensor : Ultrasonic sensor.\n\n  kGearToothSensor : Gear tooth sensor.\n\n  kPowerDistribution : Power distribution.\n\n  kPneumatics : Pneumatics.\n\n  kMiscellaneous : Miscellaneous.\n\n  kIOBreakout : IO breakout.\n\n  kServoController\n\n  kFirmwareUpdate : Firmware update.");
  pythonEnum.initializeEnum("hal.CANManufacturer", ["kAndyMark", "kBroadcast", "kCTRE", "kCopperforge", "kDEKA", "kGrapple", "kKauaiLabs", "kLM", "kMS", "kNI", "kPWF", "kREV", "kReduxRobotics", "kStudica", "kTeamUse", "kTheThriftyBot", "kVividHosting"], "The CAN manufacturer ID.\n\nTeams should use HAL_CAN_Man_kTeamUse.\n\nMembers:\n\n  kBroadcast : Broadcast.\n\n  kNI : National Instruments.\n\n  kLM : Luminary Micro.\n\n  kDEKA : DEKA Research and Development Corp.\n\n  kCTRE : Cross the Road Electronics.\n\n  kREV : REV robotics.\n\n  kGrapple : Grapple.\n\n  kMS : MindSensors.\n\n  kTeamUse : Team use.\n\n  kKauaiLabs : Kauai Labs.\n\n  kCopperforge : Copperforge.\n\n  kPWF : Playing With Fusion.\n\n  kStudica : Studica.\n\n  kTheThriftyBot : TheThriftyBot.\n\n  kReduxRobotics : Redux Robotics.\n\n  kAndyMark : AndyMark.\n\n  kVividHosting : Vivid-Hosting.");
  pythonEnum.initializeEnum("hal.CounterMode", ["kExternalDirection", "kPulseLength", "kSemiperiod", "kTwoPulse"], "The counter mode.\n\nMembers:\n\n  kTwoPulse : Two pulse mode.\n\n  kSemiperiod : Semi-period mode.\n\n  kPulseLength : Pulse length mode.\n\n  kExternalDirection : External direction mode.");
  pythonEnum.initializeEnum("hal.EncoderEncodingType", ["Encoder_k1X", "Encoder_k2X", "Encoder_k4X"], "The encoding scaling of the encoder.\n\nMembers:\n\n  Encoder_k1X\n\n  Encoder_k2X\n\n  Encoder_k4X");
  pythonEnum.initializeEnum("hal.EncoderIndexingType", ["kResetOnFallingEdge", "kResetOnRisingEdge", "kResetWhileHigh", "kResetWhileLow"], "The type of index pulse for the encoder.\n\nMembers:\n\n  kResetWhileHigh\n\n  kResetWhileLow\n\n  kResetOnFallingEdge\n\n  kResetOnRisingEdge");
  pythonEnum.initializeEnum("hal.HAL_RadioLEDState", ["HAL_RadioLED_kGreen", "HAL_RadioLED_kOff", "HAL_RadioLED_kOrange", "HAL_RadioLED_kRed"], "Members:\n\n  HAL_RadioLED_kOff\n\n  HAL_RadioLED_kGreen\n\n  HAL_RadioLED_kRed\n\n  HAL_RadioLED_kOrange");
  pythonEnum.initializeEnum("hal.HandleEnum", ["AddressableLED", "AnalogGyro", "AnalogInput", "AnalogOutput", "AnalogTrigger", "CAN", "CTREPCM", "CTREPDP", "Compressor", "Counter", "DIO", "DMA", "DigitalPWM", "DutyCycle", "Encoder", "FPGAEncoder", "Interrupt", "Notifier", "PWM", "Port", "REVPDH", "REVPH", "Relay", "SerialPort", "SimulationJni", "Solenoid", "Undefined", "Vendor"], "Enum of HAL handle types. Vendors/Teams should use Vendor (17).\n\nMembers:\n\n  Undefined\n\n  DIO\n\n  Port\n\n  Notifier\n\n  Interrupt\n\n  AnalogOutput\n\n  AnalogInput\n\n  AnalogTrigger\n\n  Relay\n\n  PWM\n\n  DigitalPWM\n\n  Counter\n\n  FPGAEncoder\n\n  Encoder\n\n  Compressor\n\n  Solenoid\n\n  AnalogGyro\n\n  Vendor\n\n  SimulationJni\n\n  CAN\n\n  SerialPort\n\n  DutyCycle\n\n  DMA\n\n  AddressableLED\n\n  CTREPCM\n\n  CTREPDP\n\n  REVPDH\n\n  REVPH");
  pythonEnum.initializeEnum("hal.I2CPort", ["kInvalid", "kMXP", "kOnboard"], "Members:\n\n  kInvalid\n\n  kOnboard\n\n  kMXP");
  pythonEnum.initializeEnum("hal.MatchType", ["elimination", "none", "practice", "qualification"], "Members:\n\n  none\n\n  practice\n\n  qualification\n\n  elimination");
  pythonEnum.initializeEnum("hal.PowerDistributionType", ["kAutomatic", "kCTRE", "kRev"], "The types of power distribution devices.\n\nMembers:\n\n  kAutomatic : Automatically determines the module type\n\n  kCTRE : CTRE (Cross The Road Electronics) Power Distribution Panel (PDP).\n\n  kRev : REV Power Distribution Hub (PDH).");
  pythonEnum.initializeEnum("hal.REVPHCompressorConfigType", ["kAnalog", "kDigital", "kDisabled", "kHybrid"], "The compressor configuration type\n\nMembers:\n\n  kDisabled : Disabled.\n\n  kDigital : Digital.\n\n  kAnalog : Analog.\n\n  kHybrid : Hybrid.");
  pythonEnum.initializeEnum("hal.RuntimeType", ["HAL_Runtime_RoboRIO", "HAL_Runtime_RoboRIO2", "HAL_Runtime_Simulation"], "Runtime type.\n\nMembers:\n\n  HAL_Runtime_RoboRIO : roboRIO 1.0\n\n  HAL_Runtime_RoboRIO2 : roboRIO 2.0\n\n  HAL_Runtime_Simulation : Simulation runtime");
  pythonEnum.initializeEnum("hal.SPIMode", ["kMode0", "kMode1", "kMode2", "kMode3"], "SPI mode.\n\nMembers:\n\n  kMode0 : Clock idle low, data sampled on rising edge.\n\n  kMode1 : Clock idle low, data sampled on falling edge.\n\n  kMode2 : Clock idle high, data sampled on falling edge.\n\n  kMode3 : Clock idle high, data sampled on rising edge.");
  pythonEnum.initializeEnum("hal.SPIPort", ["kInvalid", "kMXP", "kOnboardCS0", "kOnboardCS1", "kOnboardCS2", "kOnboardCS3"], "SPI port.\n\nMembers:\n\n  kInvalid : Invalid port number.\n\n  kOnboardCS0 : Onboard SPI bus port CS0.\n\n  kOnboardCS1 : Onboard SPI bus port CS1.\n\n  kOnboardCS2 : Onboard SPI bus port CS2.\n\n  kOnboardCS3 : Onboard SPI bus port CS3.\n\n  kMXP : MXP (roboRIO MXP) SPI bus port.");
  pythonEnum.initializeEnum("hal.SerialPort", ["MXP", "Onboard", "USB1", "USB2"], "Members:\n\n  Onboard\n\n  MXP\n\n  USB1\n\n  USB2");
  pythonEnum.initializeEnum("hal.SimValueDirection", ["HAL_SimValueBidir", "HAL_SimValueInput", "HAL_SimValueOutput"], "Direction of a simulated value (from the perspective of user code).\n\nMembers:\n\n  HAL_SimValueInput : input to user code from the simulator\n\n  HAL_SimValueOutput : output from user code to the simulator\n\n  HAL_SimValueBidir : bidirectional between user code and simulator");
  pythonEnum.initializeEnum("hal.Type", ["BOOLEAN", "DOUBLE", "ENUM", "INT", "LONG", "UNASSIGNED"], "Members:\n\n  UNASSIGNED\n\n  BOOLEAN\n\n  DOUBLE\n\n  ENUM\n\n  INT\n\n  LONG");
  pythonEnum.initializeEnum("hal.tInstances", ["kADXL345_I2C", "kADXL345_SPI", "kCANPlugin_2CAN", "kCANPlugin_BlackJagBridge", "kCommand2_Scheduler", "kCommand_Scheduler", "kDashboard_AdvantageScope", "kDashboard_Elastic", "kDashboard_FRCWebComponents", "kDashboard_Glass", "kDashboard_LabVIEW", "kDashboard_QFRCDashboard", "kDashboard_Shuffleboard", "kDashboard_SmartDashboard", "kDashboard_Unknown", "kDataLogLocation_Onboard", "kDataLogLocation_USB", "kDriverStationCIO_Analog", "kDriverStationCIO_DigitalIn", "kDriverStationCIO_DigitalOut", "kDriverStationEIO_Acceleration", "kDriverStationEIO_AnalogIn", "kDriverStationEIO_AnalogOut", "kDriverStationEIO_Button", "kDriverStationEIO_DigitalIn", "kDriverStationEIO_DigitalOut", "kDriverStationEIO_Encoder", "kDriverStationEIO_FixedDigitalOut", "kDriverStationEIO_LED", "kDriverStationEIO_PWM", "kDriverStationEIO_TouchSlider", "kFramework_AdvantageKit", "kFramework_CommandControl", "kFramework_Iterative", "kFramework_MagicBot", "kFramework_ROS", "kFramework_RobotBuilder", "kFramework_Simple", "kFramework_Timed", "kKinematics_DifferentialDrive", "kKinematics_MecanumDrive", "kKinematics_SwerveDrive", "kLanguage_CPlusPlus", "kLanguage_DotNet", "kLanguage_Java", "kLanguage_Kotlin", "kLanguage_LabVIEW", "kLanguage_Python", "kLanguage_Rust", "kLoggingFramework_AdvantageKit", "kLoggingFramework_DogLog", "kLoggingFramework_Epilogue", "kLoggingFramework_Monologue", "kLoggingFramework_Other", "kOdometry_DifferentialDrive", "kOdometry_MecanumDrive", "kOdometry_SwerveDrive", "kPDP_CTRE", "kPDP_REV", "kPDP_Unknown", "kRobotDrive2_DifferentialArcade", "kRobotDrive2_DifferentialCurvature", "kRobotDrive2_DifferentialTank", "kRobotDrive2_KilloughCartesian", "kRobotDrive2_KilloughPolar", "kRobotDrive2_MecanumCartesian", "kRobotDrive2_MecanumPolar", "kRobotDriveSwerve_AdvantageKit", "kRobotDriveSwerve_CTRE", "kRobotDriveSwerve_MaxSwerve", "kRobotDriveSwerve_Other", "kRobotDriveSwerve_YAGSL", "kRobotDrive_ArcadeButtonSpin", "kRobotDrive_ArcadeRatioCurve", "kRobotDrive_ArcadeStandard", "kRobotDrive_MecanumCartesian", "kRobotDrive_MecanumPolar", "kRobotDrive_Tank", "kSmartDashboard_Instance", "kSmartDashboard_LiveWindow"], "Members:\n\n  kLanguage_LabVIEW\n\n  kLanguage_CPlusPlus\n\n  kLanguage_Java\n\n  kLanguage_Python\n\n  kLanguage_DotNet\n\n  kLanguage_Kotlin\n\n  kLanguage_Rust\n\n  kCANPlugin_BlackJagBridge\n\n  kCANPlugin_2CAN\n\n  kFramework_Iterative\n\n  kFramework_Simple\n\n  kFramework_CommandControl\n\n  kFramework_Timed\n\n  kFramework_ROS\n\n  kFramework_RobotBuilder\n\n  kFramework_AdvantageKit\n\n  kFramework_MagicBot\n\n  kRobotDrive_ArcadeStandard\n\n  kRobotDrive_ArcadeButtonSpin\n\n  kRobotDrive_ArcadeRatioCurve\n\n  kRobotDrive_Tank\n\n  kRobotDrive_MecanumPolar\n\n  kRobotDrive_MecanumCartesian\n\n  kRobotDrive2_DifferentialArcade\n\n  kRobotDrive2_DifferentialTank\n\n  kRobotDrive2_DifferentialCurvature\n\n  kRobotDrive2_MecanumCartesian\n\n  kRobotDrive2_MecanumPolar\n\n  kRobotDrive2_KilloughCartesian\n\n  kRobotDrive2_KilloughPolar\n\n  kRobotDriveSwerve_Other\n\n  kRobotDriveSwerve_YAGSL\n\n  kRobotDriveSwerve_CTRE\n\n  kRobotDriveSwerve_MaxSwerve\n\n  kRobotDriveSwerve_AdvantageKit\n\n  kDriverStationCIO_Analog\n\n  kDriverStationCIO_DigitalIn\n\n  kDriverStationCIO_DigitalOut\n\n  kDriverStationEIO_Acceleration\n\n  kDriverStationEIO_AnalogIn\n\n  kDriverStationEIO_AnalogOut\n\n  kDriverStationEIO_Button\n\n  kDriverStationEIO_LED\n\n  kDriverStationEIO_DigitalIn\n\n  kDriverStationEIO_DigitalOut\n\n  kDriverStationEIO_FixedDigitalOut\n\n  kDriverStationEIO_PWM\n\n  kDriverStationEIO_Encoder\n\n  kDriverStationEIO_TouchSlider\n\n  kADXL345_SPI\n\n  kADXL345_I2C\n\n  kCommand_Scheduler\n\n  kCommand2_Scheduler\n\n  kSmartDashboard_Instance\n\n  kSmartDashboard_LiveWindow\n\n  kKinematics_DifferentialDrive\n\n  kKinematics_MecanumDrive\n\n  kKinematics_SwerveDrive\n\n  kOdometry_DifferentialDrive\n\n  kOdometry_MecanumDrive\n\n  kOdometry_SwerveDrive\n\n  kDashboard_Unknown\n\n  kDashboard_Glass\n\n  kDashboard_SmartDashboard\n\n  kDashboard_Shuffleboard\n\n  kDashboard_Elastic\n\n  kDashboard_LabVIEW\n\n  kDashboard_AdvantageScope\n\n  kDashboard_QFRCDashboard\n\n  kDashboard_FRCWebComponents\n\n  kDataLogLocation_Onboard\n\n  kDataLogLocation_USB\n\n  kLoggingFramework_Other\n\n  kLoggingFramework_Epilogue\n\n  kLoggingFramework_Monologue\n\n  kLoggingFramework_AdvantageKit\n\n  kLoggingFramework_DogLog\n\n  kPDP_CTRE\n\n  kPDP_REV\n\n  kPDP_Unknown");
  pythonEnum.initializeEnum("hal.tResourceType", ["kResourceType_ADIS16448", "kResourceType_ADIS16470", "kResourceType_ADXL345", "kResourceType_ADXL362", "kResourceType_ADXRS450", "kResourceType_Accelerometer", "kResourceType_AddressableLEDs", "kResourceType_AnalogChannel", "kResourceType_AnalogOutput", "kResourceType_AnalogTrigger", "kResourceType_AnalogTriggerOutput", "kResourceType_AxisCamera", "kResourceType_BangBangController", "kResourceType_Button", "kResourceType_CAN", "kResourceType_CANJaguar", "kResourceType_CANPlugin", "kResourceType_CANTalonSRX", "kResourceType_CANifier", "kResourceType_CTRE_future1", "kResourceType_CTRE_future10", "kResourceType_CTRE_future11", "kResourceType_CTRE_future12", "kResourceType_CTRE_future13", "kResourceType_CTRE_future14", "kResourceType_CTRE_future2", "kResourceType_CTRE_future3", "kResourceType_CTRE_future4", "kResourceType_CTRE_future5", "kResourceType_CTRE_future6", "kResourceType_CTRE_future7", "kResourceType_CTRE_future8", "kResourceType_CTRE_future9", "kResourceType_ChoreoTrajectory", "kResourceType_ChoreoTrigger", "kResourceType_Command", "kResourceType_Compressor", "kResourceType_Controller", "kResourceType_Counter", "kResourceType_Dashboard", "kResourceType_DataLogManager", "kResourceType_DigilentDMC60", "kResourceType_DigitalGlitchFilter", "kResourceType_DigitalInput", "kResourceType_DigitalOutput", "kResourceType_DriverStationCIO", "kResourceType_DriverStationEIO", "kResourceType_DriverStationLCD", "kResourceType_DutyCycle", "kResourceType_Encoder", "kResourceType_ExponentialProfile", "kResourceType_Framework", "kResourceType_FusionVenom", "kResourceType_GearTooth", "kResourceType_Gyro", "kResourceType_HiTechnicAccel", "kResourceType_HiTechnicColorSensor", "kResourceType_HiTechnicCompass", "kResourceType_I2C", "kResourceType_Jaguar", "kResourceType_Joystick", "kResourceType_Kinect", "kResourceType_KinectStick", "kResourceType_Kinematics", "kResourceType_Koors40", "kResourceType_Language", "kResourceType_LaserShark", "kResourceType_LinearFilter", "kResourceType_LoggingFramework", "kResourceType_MindsensorsSD540", "kResourceType_Module", "kResourceType_NavX", "kResourceType_NidecBrushless", "kResourceType_Odometry", "kResourceType_PCM", "kResourceType_PCVideoServer", "kResourceType_PDP", "kResourceType_PIDController", "kResourceType_PIDController2", "kResourceType_PS4Controller", "kResourceType_PWFSEN36005", "kResourceType_PWM", "kResourceType_PWMTalonSRX", "kResourceType_PWMVictorSPX", "kResourceType_PathFindingCommand", "kResourceType_PathPlannerAuto", "kResourceType_PathPlannerPath", "kResourceType_PathWeaverTrajectory", "kResourceType_PhotonCamera", "kResourceType_PhotonPoseEstimator", "kResourceType_PigeonIMU", "kResourceType_Pixy", "kResourceType_Pixy2", "kResourceType_Preferences", "kResourceType_ProfiledPIDController", "kResourceType_Redux_future1", "kResourceType_Redux_future2", "kResourceType_Redux_future3", "kResourceType_Redux_future4", "kResourceType_Redux_future5", "kResourceType_Relay", "kResourceType_RevSPARK", "kResourceType_RevServoHub", "kResourceType_RevSparkFlexCAN", "kResourceType_RevSparkFlexPWM", "kResourceType_RevSparkMaxCAN", "kResourceType_RevSparkMaxPWM", "kResourceType_RobotDrive", "kResourceType_SPI", "kResourceType_SRF08", "kResourceType_ScanseSweep", "kResourceType_SerialPort", "kResourceType_Servo", "kResourceType_Shuffleboard", "kResourceType_SmartDashboard", "kResourceType_Solenoid", "kResourceType_Talon", "kResourceType_TalonFX", "kResourceType_Task", "kResourceType_ThriftyNova", "kResourceType_TrapezoidProfile", "kResourceType_Ultrasonic", "kResourceType_Units", "kResourceType_UsbCamera", "kResourceType_Victor", "kResourceType_VictorSP", "kResourceType_XboxController"], "Members:\n\n  kResourceType_Controller\n\n  kResourceType_Module\n\n  kResourceType_Language\n\n  kResourceType_CANPlugin\n\n  kResourceType_Accelerometer\n\n  kResourceType_ADXL345\n\n  kResourceType_AnalogChannel\n\n  kResourceType_AnalogTrigger\n\n  kResourceType_AnalogTriggerOutput\n\n  kResourceType_CANJaguar\n\n  kResourceType_Compressor\n\n  kResourceType_Counter\n\n  kResourceType_Dashboard\n\n  kResourceType_DigitalInput\n\n  kResourceType_DigitalOutput\n\n  kResourceType_DriverStationCIO\n\n  kResourceType_DriverStationEIO\n\n  kResourceType_DriverStationLCD\n\n  kResourceType_Encoder\n\n  kResourceType_GearTooth\n\n  kResourceType_Gyro\n\n  kResourceType_I2C\n\n  kResourceType_Framework\n\n  kResourceType_Jaguar\n\n  kResourceType_Joystick\n\n  kResourceType_Kinect\n\n  kResourceType_KinectStick\n\n  kResourceType_PIDController\n\n  kResourceType_Preferences\n\n  kResourceType_PWM\n\n  kResourceType_Relay\n\n  kResourceType_RobotDrive\n\n  kResourceType_SerialPort\n\n  kResourceType_Servo\n\n  kResourceType_Solenoid\n\n  kResourceType_SPI\n\n  kResourceType_Task\n\n  kResourceType_Ultrasonic\n\n  kResourceType_Victor\n\n  kResourceType_Button\n\n  kResourceType_Command\n\n  kResourceType_AxisCamera\n\n  kResourceType_PCVideoServer\n\n  kResourceType_SmartDashboard\n\n  kResourceType_Talon\n\n  kResourceType_HiTechnicColorSensor\n\n  kResourceType_HiTechnicAccel\n\n  kResourceType_HiTechnicCompass\n\n  kResourceType_SRF08\n\n  kResourceType_AnalogOutput\n\n  kResourceType_VictorSP\n\n  kResourceType_PWMTalonSRX\n\n  kResourceType_CANTalonSRX\n\n  kResourceType_ADXL362\n\n  kResourceType_ADXRS450\n\n  kResourceType_RevSPARK\n\n  kResourceType_MindsensorsSD540\n\n  kResourceType_DigitalGlitchFilter\n\n  kResourceType_ADIS16448\n\n  kResourceType_PDP\n\n  kResourceType_PCM\n\n  kResourceType_PigeonIMU\n\n  kResourceType_NidecBrushless\n\n  kResourceType_CANifier\n\n  kResourceType_TalonFX\n\n  kResourceType_CTRE_future1\n\n  kResourceType_CTRE_future2\n\n  kResourceType_CTRE_future3\n\n  kResourceType_CTRE_future4\n\n  kResourceType_CTRE_future5\n\n  kResourceType_CTRE_future6\n\n  kResourceType_LinearFilter\n\n  kResourceType_XboxController\n\n  kResourceType_UsbCamera\n\n  kResourceType_NavX\n\n  kResourceType_Pixy\n\n  kResourceType_Pixy2\n\n  kResourceType_ScanseSweep\n\n  kResourceType_Shuffleboard\n\n  kResourceType_CAN\n\n  kResourceType_DigilentDMC60\n\n  kResourceType_PWMVictorSPX\n\n  kResourceType_RevSparkMaxPWM\n\n  kResourceType_RevSparkMaxCAN\n\n  kResourceType_ADIS16470\n\n  kResourceType_PIDController2\n\n  kResourceType_ProfiledPIDController\n\n  kResourceType_Kinematics\n\n  kResourceType_Odometry\n\n  kResourceType_Units\n\n  kResourceType_TrapezoidProfile\n\n  kResourceType_DutyCycle\n\n  kResourceType_AddressableLEDs\n\n  kResourceType_FusionVenom\n\n  kResourceType_CTRE_future7\n\n  kResourceType_CTRE_future8\n\n  kResourceType_CTRE_future9\n\n  kResourceType_CTRE_future10\n\n  kResourceType_CTRE_future11\n\n  kResourceType_CTRE_future12\n\n  kResourceType_CTRE_future13\n\n  kResourceType_CTRE_future14\n\n  kResourceType_ExponentialProfile\n\n  kResourceType_PS4Controller\n\n  kResourceType_PhotonCamera\n\n  kResourceType_PhotonPoseEstimator\n\n  kResourceType_PathPlannerPath\n\n  kResourceType_PathPlannerAuto\n\n  kResourceType_PathFindingCommand\n\n  kResourceType_Redux_future1\n\n  kResourceType_Redux_future2\n\n  kResourceType_Redux_future3\n\n  kResourceType_Redux_future4\n\n  kResourceType_Redux_future5\n\n  kResourceType_RevSparkFlexCAN\n\n  kResourceType_RevSparkFlexPWM\n\n  kResourceType_BangBangController\n\n  kResourceType_DataLogManager\n\n  kResourceType_LoggingFramework\n\n  kResourceType_ChoreoTrajectory\n\n  kResourceType_ChoreoTrigger\n\n  kResourceType_PathWeaverTrajectory\n\n  kResourceType_Koors40\n\n  kResourceType_ThriftyNova\n\n  kResourceType_RevServoHub\n\n  kResourceType_PWFSEN36005\n\n  kResourceType_LaserShark");
}

export function getToolboxCategory(subcategories: Category[] = []): Category {
  const category: Category = {
    kind: "category",
    name: "hal",
    contents: [
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "sessionHandle", "type": "int"}], "tooltip": "Closes a CAN stream.\n\n:param sessionHandle: the session to close", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "CAN_CloseStreamSession"}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int, int, int, int, int]", "args": [], "tooltip": "Gets CAN status information.\n\n:param out: percentBusUtilization the bus utilization\n:param out: busOffCount           the number of bus off errors\n:param out: txFullCount           the number of tx full errors\n:param out: receiveErrorCount     the number of receive errors\n:param out: transmitErrorCount    the number of transmit errors\n:param out: status                Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "CAN_GetCANStatus"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "messageID", "type": "int"}, {"name": "messageIDMask", "type": "int"}, {"name": "maxMessages", "type": "int"}], "tooltip": "Opens a CAN stream.\n\n:param out: sessionHandle output for the session handle\n:param in:  messageID     the message ID to read\n:param in:  messageIDMask the message ID mask\n:param in:  maxMessages   the maximum number of messages to stream\n:param out: status        Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "CAN_OpenStreamSession"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int, int, int]", "args": [{"name": "messageIDMask", "type": "int"}, {"name": "data", "type": "Buffer"}], "tooltip": "Receives a CAN message.\n\n:param out: messageID     store for the received message ID\n:param in:  messageIDMask the message ID mask to look for\n:param out: data          data output (8 bytes)\n:param out: dataSize      data length (0-8 bytes)\n:param out: timeStamp     the packet received timestamp (based off of\n            CLOCK_MONOTONIC)\n:param out: status        Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "CAN_ReceiveMessage"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "messageID", "type": "int"}, {"name": "data", "type": "Buffer"}, {"name": "periodMs", "type": "int"}], "tooltip": "Sends a CAN message.\n\n:param in:  messageID the CAN ID to send\n:param in:  data      the data to send (0-8 bytes)\n:param in:  dataSize  the size of the data to send (0-8 bytes)\n:param in:  periodMs  the period to repeat the packet at. Use\n            HAL_CAN_SEND_PERIOD_NO_REPEAT to not repeat.\n:param out: status    Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "CAN_SendMessage"}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[hal._wpiHal.HAL_RadioLEDState, int]", "args": [], "tooltip": "Get the state of the \"Radio\" LED.\n\n:param out: status the error code, or 0 for success\n\n:returns: The state of the LED.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "HAL_GetRadioLEDState"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "state", "type": "hal._wpiHal.HAL_RadioLEDState"}], "tooltip": "Set the state of the \"Radio\" LED.\n\n:param state: The state to set the LED to.\n:param out:   status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "HAL_SetRadioLEDState"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myHAL_RadioLEDState"}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Allocates a DO PWM Generator.\n\n:param out: status Error status variable. 0 on success.\n\n:returns: the allocated digital PWM handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "allocateDigitalPWM"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}], "tooltip": "Calibrates the analog gyro.\n\nThis happens by calculating the average value of the gyro over 5 seconds, and\nsetting that as the center. Note that this call blocks for 5 seconds to\nperform this.\n\n:param in:  handle the gyro handle\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "calibrateAnalogGyro"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "notifierHandle", "type": "int"}], "tooltip": "Cancels the next notifier alarm.\n\nThis does not cause HAL_WaitForNotifierAlarm to return.\n\n:param in:  notifierHandle the notifier handle\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "cancelNotifierAlarm"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "channel", "type": "int"}], "tooltip": "Checks that the analog output channel number is valid.\nVerifies that the analog channel number is one of the legal channel numbers.\nChannel numbers are 0-based.\n\n:param in: channel The analog output channel number.\n\n:returns: Analog channel is valid", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "checkAnalogInputChannel"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "module", "type": "int"}], "tooltip": "Checks that the analog module number is valid.\n\n:param in: module The analog module number.\n\n:returns: Analog module is valid and present", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "checkAnalogModule"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "channel", "type": "int"}], "tooltip": "Checks that the analog output channel number is valid.\n\nVerifies that the analog channel number is one of the legal channel numbers.\nChannel numbers are 0-based.\n\n:returns: Analog channel is valid", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "checkAnalogOutputChannel"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "channel", "type": "int"}], "tooltip": "Checks if a solenoid channel number is valid.\n\n:param in: channel the channel to check\n\n:returns: true if the channel is valid, otherwise false", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "checkCTREPCMSolenoidChannel"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "channel", "type": "int"}], "tooltip": "Checks if a DIO channel is valid.\n\n:param channel: the channel number to check\n\n:returns: true if the channel is valid, otherwise false", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "checkDIOChannel"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "channel", "type": "int"}], "tooltip": "Checks if a pwm channel is valid.\n\n:param channel: the channel to check\n\n:returns: true if the channel is valid, otherwise false", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "checkPWMChannel"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "channel", "type": "int"}], "tooltip": "Checks if a PowerDistribution channel is valid.\n\n:param handle:  the module handle\n:param channel: the channel to check\n\n:returns: true if the channel is valid, otherwise false", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "checkPowerDistributionChannel"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "module", "type": "int"}, {"name": "type", "type": "hal._wpiHal.PowerDistributionType"}], "tooltip": "Checks if a PowerDistribution module is valid.\n\n:param module: the module to check\n:param type:   the type of module\n\n:returns: true if the module is valid, otherwise false", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "checkPowerDistributionModule"}, "inputs": {"ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myPowerDistributionType"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "module", "type": "int"}], "tooltip": "Checks if a PH module (CAN ID) is valid.\n\n:param in: module the module to check\n\n:returns: true if the module is valid, otherwise false", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "checkREVPHModuleNumber"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "channel", "type": "int"}], "tooltip": "Checks if a solenoid channel number is valid.\n\n:param in: channel the channel to check\n\n:returns: true if the channel is valid, otherwise false", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "checkREVPHSolenoidChannel"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "channel", "type": "int"}], "tooltip": "Checks if a relay channel is valid.\n\n:param channel: the channel to check\n\n:returns: true if the channel is valid, otherwise false", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "checkRelayChannel"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "analogTriggerHandle", "type": "int"}], "tooltip": "Frees an analog trigger.\n\n:param in: analogTriggerHandle the trigger handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "cleanAnalogTrigger"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "handle", "type": "int"}], "tooltip": "Frees a CAN device\n\n:param handle: the CAN handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "cleanCAN"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "interruptHandle", "type": "int"}], "tooltip": "Frees an interrupt.\n\n:param interruptHandle: the interrupt handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "cleanInterrupts"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "notifierHandle", "type": "int"}], "tooltip": "Cleans a notifier.\n\nNote this also stops a notifier if it is already running.\n\n:param in: notifierHandle the notifier handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "cleanNotifier"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "handle", "type": "int"}], "tooltip": "Cleans a PowerDistribution module.\n\n:param handle: the module handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "cleanPowerDistribution"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}], "tooltip": "Clears all sticky faults on this device.\n\n:param in:  handle  the PCM handle\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "clearAllCTREPCMStickyFaults"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "counterHandle", "type": "int"}], "tooltip": "Disables the down counting source to the counter.\n\n:param in:  counterHandle the counter handle\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "clearCounterDownSource"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "counterHandle", "type": "int"}], "tooltip": "Disables the up counting source to the counter.\n\n:param in:  counterHandle the counter handle\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "clearCounterUpSource"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}], "tooltip": "Clears any PowerDistribution sticky faults.\n\n:param in:  handle the module handle\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "clearPowerDistributionStickyFaults"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}], "tooltip": "Clears the sticky faults.\n\n:param in:  handle  the PH handle\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "clearREVPHStickyFaults"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}], "tooltip": "Clears the receive buffer of the serial port.\n\n:param in:  handle  the serial port handle\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "clearSerial"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "port", "type": "hal._wpiHal.I2CPort"}], "tooltip": "Closes an I2C port\n\n:param port: The I2C port, 0 for the on-board, 1 for the MXP.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "closeI2C"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myI2CPort"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}], "tooltip": "Closes the SPI port.\n\n:param port: The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for MXP", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "closeSPI"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "handle", "type": "int"}], "tooltip": "Closes a serial port.\n\n:param in: handle  the serial port handle to close", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "closeSerial"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}, {"name": "csToSclkTicks", "type": "int"}, {"name": "stallTicks", "type": "int"}, {"name": "pow2BytesPerRead", "type": "int"}], "tooltip": "Configure the Auto SPI Stall time between reads.\n\n:param in:  port             The number of the port to use. 0-3 for Onboard\n            CS0-CS2, 4 for MXP.\n:param in:  csToSclkTicks    the number of ticks to wait before asserting the\n            cs pin\n:param in:  stallTicks       the number of ticks to stall for\n:param in:  pow2BytesPerRead the number of bytes to read before stalling\n:param out: status          the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "configureSPIAutoStall"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "index", "type": "int"}, {"name": "handleType", "type": "hal._wpiHal.HandleEnum"}, {"name": "version", "type": "int"}], "tooltip": "Create a handle for a specific index, type and version.\n\nNote the version is not checked on the roboRIO.\n\n:param index:      the index\n:param handleType: the handle type\n:param version:    the handle version\n\n:returns: the created handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "createHandle"}, "inputs": {"ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myHandleEnum"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "channel", "type": "int"}, {"name": "module", "type": "int"}], "tooltip": "Create a port handle.\n\n:param channel: the channel\n:param module:  the module\n\n:returns: port handle for the module and channel", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "createPortHandle"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "channel", "type": "int"}], "tooltip": "Create a port handle for SPI.\n\n:param channel: the SPI channel\n\n:returns: port handle for the channel", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "createPortHandleForSPI"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}], "tooltip": "Disables a termination character for reads.\n\n:param in:  handle  the serial port handle\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "disableSerialTermination"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "terminator", "type": "str"}], "tooltip": "Sets the termination character that terminates a read.\n\nBy default this is disabled.\n\n:param in:  handle      the serial port handle\n:param in:  terminator  the termination character to set\n:param out: status     the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "enableSerialTermination"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [], "tooltip": "Causes HAL_RunMain() to exit.\n\nIf HAL_SetMain() has been called, this calls the exit function provided\nto that function.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "exitMain"}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "unexpandedLower", "type": "int"}], "tooltip": "Given an 32 bit FPGA time, expand it to the nearest likely 64 bit FPGA time.\n\nNote: This is making the assumption that the timestamp being converted is\nalways in the past.  If you call this with a future timestamp, it probably\nwill make it in the past.  If you wait over 70 minutes between capturing the\nbottom 32 bits of the timestamp and expanding it, you will be off by\nmultiples of 1<<32 microseconds.\n\n:param in:  unexpandedLower 32 bit FPGA time\n:param out: status the error code, or 0 for success\n\n:returns: The current time in microseconds according to the FPGA (since FPGA\n          reset) as a 64 bit number.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "expandFPGATime"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "index", "type": "int"}], "tooltip": "Fire a single solenoid shot.\n\n:param in:  handle  the PCM handle\n:param in:  index solenoid index\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "fireCTREPCMOneShot"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "index", "type": "int"}, {"name": "durMs", "type": "int"}], "tooltip": "Fire a single solenoid shot for the specified duration.\n\n:param in:  handle  the PH handle\n:param in:  index solenoid index\n:param in:  durMs shot duration in ms\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "fireREVPHOneShot"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}], "tooltip": "Flushes the serial write buffer out to the port.\n\n:param in:  handle  the serial port handle\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "flushSerial"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}], "tooltip": "Immediately forces an SPI read to happen.\n\n:param in:  port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n            for MXP.\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "forceSPIAutoRead"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "handle", "type": "int"}], "tooltip": "Free the Addressable LED Handle.\n\n:param in: handle the Addressable LED handle to free", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "freeAddressableLED"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "handle", "type": "int"}], "tooltip": "Frees an analog gyro.\n\n:param handle: the gyro handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "freeAnalogGyro"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "analogPortHandle", "type": "int"}], "tooltip": "Frees an analog input port.\n\n:param analogPortHandle: Handle to the analog port.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "freeAnalogInputPort"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "analogOutputHandle", "type": "int"}], "tooltip": "Frees an analog output port.\n\n:param analogOutputHandle: the analog output handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "freeAnalogOutputPort"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "handle", "type": "int"}], "tooltip": "Frees a PCM handle.\n\n:param in: handle the PCMhandle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "freeCTREPCM"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "counterHandle", "type": "int"}], "tooltip": "Frees a counter.\n\n:param in: counterHandle the counter handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "freeCounter"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "dioPortHandle", "type": "int"}], "tooltip": "Frees a DIO port.\n\n:param dioPortHandle: the DIO channel handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "freeDIOPort"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "pwmGenerator", "type": "int"}], "tooltip": "Frees the resource associated with a DO PWM generator.\n\n:param in: pwmGenerator the digital PWM handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "freeDigitalPWM"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "dutyCycleHandle", "type": "int"}], "tooltip": "Free a DutyCycle.\n\n:param dutyCycleHandle: the duty cycle handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "freeDutyCycle"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "encoderHandle", "type": "int"}], "tooltip": "Frees an encoder.\n\n:param in: encoderHandle the encoder handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "freeEncoder"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "pwmPortHandle", "type": "int"}], "tooltip": "Frees a PWM port.\n\n:param in: pwmPortHandle the pwm handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "freePWMPort"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "handle", "type": "int"}], "tooltip": "Frees a PH handle.\n\n:param in: handle the PH handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "freeREVPH"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "relayPortHandle", "type": "int"}], "tooltip": "Frees a relay port.\n\n:param relayPortHandle: the relay handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "freeRelayPort"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}], "tooltip": "Frees an SPI automatic accumulator.\n\n:param in:  port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n            for MXP.\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "freeSPIAuto"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "float", "args": [], "tooltip": "Gets the x-axis acceleration.\n\nThis is a floating point value in units of 1 g-force.\n\n:returns: the X acceleration", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAccelerometerX"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "float", "args": [], "tooltip": "Gets the y-axis acceleration.\n\nThis is a floating point value in units of 1 g-force.\n\n:returns: the Y acceleration", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAccelerometerY"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "float", "args": [], "tooltip": "Gets the z-axis acceleration.\n\nThis is a floating point value in units of 1 g-force.\n\n:returns: the Z acceleration", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAccelerometerZ"}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "analogPortHandle", "type": "int"}], "tooltip": "Read the number of accumulated values.\n\nRead the count of the accumulated values since the accumulator was last\nReset().\n\n:param in:  analogPortHandle Handle to the analog port.\n:param out: status Error status variable. 0 on success.\n\n:returns: The number of times samples from the channel were accumulated.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAccumulatorCount"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int, int]", "args": [{"name": "analogPortHandle", "type": "int"}], "tooltip": "Read the accumulated value and the number of accumulated values atomically.\n\nThis function reads the value and count from the FPGA atomically.\nThis can be used for averaging.\n\n:param in:  analogPortHandle Handle to the analog port.\n:param in:  value Pointer to the 64-bit accumulated output.\n:param in:  count Pointer to the number of accumulation cycles.\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAccumulatorOutput"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "analogPortHandle", "type": "int"}], "tooltip": "Read the accumulated value.\n\nRead the value that has been accumulating on channel 1.\nThe accumulator is attached after the oversample and average engine.\n\n:param in:  analogPortHandle Handle to the analog port.\n:param out: status Error status variable. 0 on success.\n\n:returns: The 64-bit value accumulated since the last Reset().", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAccumulatorValue"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "axes", "type": "hal._wpiHal.JoystickAxes"}, {"name": "povs", "type": "hal._wpiHal.JoystickPOVs"}, {"name": "buttons", "type": "hal._wpiHal.JoystickButtons"}], "tooltip": "", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAllJoystickData"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myJoystickAxes"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myJoystickPOVs"}}}}, "ARG2": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myJoystickButtons"}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[hal._wpiHal.AllianceStationID, int]", "args": [], "tooltip": "Gets the current alliance station ID.\n\n:param out: status the error code, or 0 for success\n\n:returns: the alliance station ID", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAllianceStation"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "analogPortHandle", "type": "int"}], "tooltip": "Gets the number of averaging bits.\n\nThis gets the number of averaging bits from the FPGA. The actual number of\naveraged samples is 2**bits. The averaging is done automatically in the FPGA.\n\n:param in:  analogPortHandle Handle to the analog port to use.\n:param out: status the error code, or 0 for success\n\n:returns: Bits to average.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAnalogAverageBits"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "analogPortHandle", "type": "int"}], "tooltip": "Gets a sample from the output of the oversample and average engine for the\nchannel.\n\nThe sample is 12-bit + the value configured in SetOversampleBits().\nThe value configured in SetAverageBits() will cause this value to be averaged\n2**bits number of samples. This is not a sliding window.  The sample will not\nchange until 2**(OversampleBits + AverageBits) samples have been acquired\nfrom the module on this channel. Use GetAverageVoltage() to get the analog\nvalue in calibrated units.\n\n:param in:  analogPortHandle Handle to the analog port to use.\n:param out: status the error code, or 0 for success\n\n:returns: A sample from the oversample and average engine for the channel.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAnalogAverageValue"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "analogPortHandle", "type": "int"}], "tooltip": "Gets a scaled sample from the output of the oversample and average engine for\nthe channel.\n\nThe value is scaled to units of Volts using the calibrated scaling data from\nGetLSBWeight() and GetOffset(). Using oversampling will cause this value to\nbe higher resolution, but it will update more slowly. Using averaging will\ncause this value to be more stable, but it will update more slowly.\n\n:param in:  analogPortHandle Handle to the analog port to use.\n:param out: status the error code, or 0 for success\n\n:returns: A scaled sample from the output of the oversample and average engine\n          for the channel.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAnalogAverageVoltage"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Gets the gyro angle in degrees.\n\n:param in:  handle the gyro handle\n:param out: status Error status variable. 0 on success.\n\n:returns: the gyro angle in degrees", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAnalogGyroAngle"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Gets the calibrated gyro center.\n\nCan be used to not repeat a calibration but reconstruct the gyro object.\n\n:param in:  handle the gyro handle\n:param out: status Error status variable. 0 on success.\n\n:returns: the gyro center", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAnalogGyroCenter"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Gets the calibrated gyro offset.\n\nCan be used to not repeat a calibration but reconstruct the gyro object.\n\n:param in:  handle the gyro handle\n:param out: status Error status variable. 0 on success.\n\n:returns: the gyro offset", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAnalogGyroOffset"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Gets the gyro rate in degrees/second.\n\n:param in:  handle the gyro handle\n:param out: status Error status variable. 0 on success.\n\n:returns: the gyro rate in degrees/second", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAnalogGyroRate"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "analogPortHandle", "type": "int"}], "tooltip": "Gets the factory scaling least significant bit weight constant.\nThe least significant bit weight constant for the channel that was calibrated\nin manufacturing and stored in an eeprom in the module.\n\nVolts = ((LSB_Weight * 1e-9) * raw) - (Offset * 1e-9)\n\n:param in:  analogPortHandle Handle to the analog port to use.\n:param out: status the error code, or 0 for success\n\n:returns: Least significant bit weight.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAnalogLSBWeight"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "analogPortHandle", "type": "int"}], "tooltip": "Gets the factory scaling offset constant.\nThe offset constant for the channel that was calibrated in manufacturing and\nstored in an eeprom in the module.\n\nVolts = ((LSB_Weight * 1e-9) * raw) - (Offset * 1e-9)\n\n:param in:  analogPortHandle Handle to the analog port to use.\n:param out: status Error status variable. 0 on success.\n\n:returns: Offset constant.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAnalogOffset"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "analogOutputHandle", "type": "int"}], "tooltip": "Gets the current analog output value.\n\n:param in:  analogOutputHandle the analog output handle\n:param out: status            Error status variable. 0 on success.\n\n:returns: the current output voltage (0-5v)", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAnalogOutput"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "analogPortHandle", "type": "int"}], "tooltip": "Gets the number of oversample bits.\n\nThis gets the number of oversample bits from the FPGA. The actual number of\noversampled values is 2**bits. The oversampling is done automatically in the\nFPGA.\n\n:param in:  analogPortHandle Handle to the analog port to use.\n:param out: status          the error code, or 0 for success\n\n:returns: Bits to oversample.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAnalogOversampleBits"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [], "tooltip": "Gets the current sample rate.\n\nThis assumes one entry in the scan list.\nThis is a global setting for the Athena and effects all channels.\n\n:param out: status the error code, or 0 for success\n\n:returns: Sample rate.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAnalogSampleRate"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "analogTriggerHandle", "type": "int"}], "tooltip": "Get the FPGA index for the AnalogTrigger.\n\n:param in:  analogTriggerHandle the trigger handle\n:param out: status              Error status variable. 0 on success.\n\n:returns: the FPGA index", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAnalogTriggerFPGAIndex"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "analogTriggerHandle", "type": "int"}], "tooltip": "Returns the InWindow output of the analog trigger.\n\nTrue if the analog input is between the upper and lower limits.\n\n:param in:  analogTriggerHandle the trigger handle\n:param out: status Error status variable. 0 on success.\n\n:returns: the InWindow output of the analog trigger", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAnalogTriggerInWindow"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "analogTriggerHandle", "type": "int"}, {"name": "type", "type": "hal._wpiHal.AnalogTriggerType"}], "tooltip": "Gets the state of the analog trigger output.\n\n:param in:  analogTriggerHandle the trigger handle\n:param in:  type                the type of trigger to trigger on\n:param out: status              Error status variable. 0 on success.\n\n:returns: the state of the analog trigger output", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAnalogTriggerOutput"}, "inputs": {"ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogTriggerType"}}}}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "analogTriggerHandle", "type": "int"}], "tooltip": "Returns the TriggerState output of the analog trigger.\n\nTrue if above upper limit.\nFalse if below lower limit.\nIf in Hysteresis, maintain previous state.\n\n:param in:  analogTriggerHandle the trigger handle\n:param out: status              Error status variable. 0 on success.\n\n:returns: the TriggerState output of the analog trigger", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAnalogTriggerTriggerState"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "analogPortHandle", "type": "int"}], "tooltip": "Gets a sample straight from the channel on this module.\n\nThe sample is a 12-bit value representing the 0V to 5V range of the A/D\nconverter in the module. The units are in A/D converter codes.  Use\nGetVoltage() to get the analog value in calibrated units.\n\n:param in:  analogPortHandle Handle to the analog port to use.\n:param out: status the error code, or 0 for success\n\n:returns: A sample straight from the channel on this module.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAnalogValue"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "analogPortHandle", "type": "int"}, {"name": "rawValue", "type": "int"}], "tooltip": "Get the analog voltage from a raw value.\n\n:param in:  analogPortHandle  Handle to the analog port the values were read\n            from.\n:param in:  rawValue          The raw analog value\n:param out: status           Error status variable. 0 on success.\n\n:returns: The voltage relating to the value", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAnalogValueToVolts"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "analogPortHandle", "type": "int"}], "tooltip": "Gets a scaled sample straight from the channel on this module.\n\nThe value is scaled to units of Volts using the calibrated scaling data from\nGetLSBWeight() and GetOffset().\n\n:param in:  analogPortHandle Handle to the analog port to use.\n:param out: status the error code, or 0 for success\n\n:returns: A scaled sample straight from the channel on this module.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAnalogVoltage"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "analogPortHandle", "type": "int"}, {"name": "voltage", "type": "float"}], "tooltip": "Converts a voltage to a raw value for a specified channel.\n\nThis process depends on the calibration of each channel, so the channel must\nbe specified.\n\n@todo This assumes raw values.  Oversampling not supported as is.\n\n:param in:  analogPortHandle Handle to the analog port to use.\n:param in:  voltage The voltage to convert.\n:param out: status the error code, or 0 for success\n\n:returns: The raw value for the channel.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getAnalogVoltsToValue"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Gets if the system is in a browned out state.\n\n:param out: status the error code, or 0 for success\n\n:returns: true if the system is in a low voltage brown out, false otherwise", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getBrownedOut"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [], "tooltip": "Get the current brownout voltage setting.\n\n:param out: status the error code, or 0 for success\n\n:returns: The brownout voltage", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getBrownoutVoltage"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Reads the current value of the millisecond-resolution timer that the CAN API\nfunctions use as a time base.\n\n:returns: Current value of timer used as a base time by the CAN API in\n          milliseconds.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCANPacketBaseTime"}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [], "tooltip": "Get the current CPU temperature in degrees Celsius\n\n:param out: status the error code, or 0 for success\n\n:returns: current CPU temperature in degrees Celsius", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCPUTemp"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Get whether the PCM closed loop control is enabled.\n\n:param in:  handle  the PCM handle\n:param out: status Error status variable. 0 on success.\n\n:returns: True if closed loop control is enabled, otherwise false.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCTREPCMClosedLoopControl"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Get whether compressor is turned on.\n\n:param in:  handle  the PCM handle\n:param out: status Error status variable. 0 on success.\n\n:returns: true if the compressor is turned on", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCTREPCMCompressor"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Returns the current drawn by the compressor.\n\n:param in:  handle  the PCM handle\n:param out: status Error status variable. 0 on success.\n\n:returns: The current drawn by the compressor in amps.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCTREPCMCompressorCurrent"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Return whether the compressor current is currently too high.\n\n:param in:  handle  the PCM handle\n:param out: status Error status variable. 0 on success.\n\n:returns: True if the compressor current is too high, otherwise false.\n          @see HAL_GetCTREPCMCompressorShortedStickyFault", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCTREPCMCompressorCurrentTooHighFault"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Returns whether the compressor current has been too high since sticky\nfaults were last cleared. This fault is persistent and can be cleared by\nHAL_ClearAllCTREPCMStickyFaults()\n\n:param in:  handle  the PCM handle\n:param out: status Error status variable. 0 on success.\n\n:returns: True if the compressor current has been too high since sticky\n          faults were last cleared.\n          @see HAL_GetCTREPCMCompressorCurrentTooHighFault()", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCTREPCMCompressorCurrentTooHighStickyFault"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Returns whether the compressor is currently disconnected.\n\n:param in:  handle  the PCM handle\n:param out: status Error status variable. 0 on success.\n\n:returns: True if compressor is currently disconnected, otherwise false.\n          @see HAL_GetCTREPCMCompressorNotConnectedStickyFault()", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCTREPCMCompressorNotConnectedFault"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Returns whether the compressor has been disconnected since sticky faults\nwere last cleared. This fault is persistent and can be cleared by\nHAL_ClearAllCTREPCMStickyFaults()\n\n:param in:  handle  the PCM handle\n:param out: status Error status variable. 0 on success.\n\n:returns: True if the compressor has been disconnected since sticky faults\n          were last cleared, otherwise false.\n          @see HAL_GetCTREPCMCompressorShortedFault()", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCTREPCMCompressorNotConnectedStickyFault"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Returns whether the compressor is currently shorted.\n\n:param in:  handle  the PCM handle\n:param out: status Error status variable. 0 on success.\n\n:returns: True if the compressor is currently shorted, otherwise false.\n          @see HAL_GetCTREPCMCompressorShortedStickyFault", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCTREPCMCompressorShortedFault"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Returns whether the compressor has been shorted since sticky faults were\nlast cleared. This fault is persistent and can be cleared by\nHAL_ClearAllCTREPCMStickyFaults()\n\n:param in:  handle  the PCM handle\n:param out: status Error status variable. 0 on success.\n\n:returns: True if the compressor has been shorted since sticky faults were\n          last cleared, otherwise false.\n          @see HAL_GetCTREPCMCompressorShortedFault()", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCTREPCMCompressorShortedStickyFault"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Returns the state of the pressure switch.\n\n:param in:  handle  the PCM handle\n:param out: status Error status variable. 0 on success.\n\n:returns: True if pressure switch indicates that the system is full,\n          otherwise false.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCTREPCMPressureSwitch"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Get a bitmask of disabled solenoids.\n\n:param in:  handle  the PCM handle\n:param out: status Error status variable. 0 on success.\n\n:returns: Bitmask indicating disabled solenoids. The LSB represents solenoid 0.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCTREPCMSolenoidDisabledList"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Returns whether the solenoid is currently reporting a voltage fault.\n\n:param in:  handle  the PCM handle\n:param out: status Error status variable. 0 on success.\n\n:returns: True if solenoid is reporting a fault, otherwise false.\n          @see HAL_GetCTREPCMSolenoidVoltageStickyFault()", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCTREPCMSolenoidVoltageFault"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Returns whether the solenoid has reported a voltage fault since sticky faults\nwere last cleared. This fault is persistent and can be cleared by\nHAL_ClearAllCTREPCMStickyFaults()\n\n:param in:  handle  the PCM handle\n:param out: status Error status variable. 0 on success.\n\n:returns: True if solenoid is reporting a fault, otherwise false.\n          @see HAL_GetCTREPCMSolenoidVoltageFault()", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCTREPCMSolenoidVoltageStickyFault"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Gets a bitmask of solenoid values.\n\n:param in:  handle  the PCM handle\n:param out: status Error status variable. 0 on success.\n\n:returns: Bitmask containing the state of the solenoids. The LSB represents\n          solenoid 0.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCTREPCMSolenoids"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "str", "args": [], "tooltip": "Returns the comments from the roboRIO web interface.\n\n:param out: comments The comments string. Free with WPI_FreeString", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getComments"}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Gets the number of times the system has been disabled due to communication\nerrors with the Driver Station.\n\n:returns: number of disables due to communication errors.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCommsDisableCount"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "controlWord", "type": "hal._wpiHal.ControlWord"}], "tooltip": "Gets the current control word of the driver station.\n\nThe control word contains the robot state.\n\n:param controlWord: the control word (out)\n\n:returns: the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getControlWord"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myControlWord"}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "counterHandle", "type": "int"}], "tooltip": "Reads the current counter value.\n\nReads the value at this instant. It may still be running, so it reflects the\ncurrent value. Next time it is read, it might have a different value.\n\n:param in:  counterHandle the counter handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: the current counter value", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCounter"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "counterHandle", "type": "int"}], "tooltip": "Gets the last direction the counter value changed.\n\n:param in:  counterHandle the counter handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: the last direction the counter value changed", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCounterDirection"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "counterHandle", "type": "int"}], "tooltip": "Gets the Period of the most recent count.\n\nReturns the time interval of the most recent count. This can be used for\nvelocity calculations to determine shaft speed.\n\n:param in:  counterHandle the counter handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: the period of the last two pulses in units of seconds", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCounterPeriod"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "counterHandle", "type": "int"}], "tooltip": "Gets the Samples to Average which specifies the number of samples of the\ntimer to average when calculating the period. Perform averaging to account\nfor mechanical imperfections or as oversampling to increase resolution.\n\n:param in:  counterHandle the counter handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: SamplesToAverage The number of samples being averaged (from 1 to 127)", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCounterSamplesToAverage"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "counterHandle", "type": "int"}], "tooltip": "Determines if the clock is stopped.\n\nDetermine if the clocked input is stopped based on the MaxPeriod value set\nusing the SetMaxPeriod method. If the clock exceeds the MaxPeriod, then the\ndevice (and counter) are assumed to be stopped and it returns true.\n\n:param in:  counterHandle the counter handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: true if the most recent counter period exceeds the MaxPeriod value\n          set by SetMaxPeriod", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCounterStopped"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "isRealTime", "type": "int"}], "tooltip": "Gets the thread priority for the current thread.\n\n:param out: isRealTime Set to true if thread is real-time, otherwise false.\n:param out: status     Error status variable. 0 on success.\n\n:returns: The current thread priority. For real-time, this is 1-99 with 99\n          being highest. For non-real-time, this is 0. See \"man 7 sched\" for\n          details.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getCurrentThreadPriority"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "dioPortHandle", "type": "int"}], "tooltip": "Reads a digital value from a DIO channel.\n\n:param in:  dioPortHandle the digital port handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: the state of the specified channel", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getDIO"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "dioPortHandle", "type": "int"}], "tooltip": "Reads the direction of a DIO channel.\n\n:param in:  dioPortHandle the digital port handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: true for input, false for output", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getDIODirection"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "dutyCycleHandle", "type": "int"}], "tooltip": "Get the FPGA index for the DutyCycle.\n\n:param in:  dutyCycleHandle the duty cycle handle\n:param out: status Error status variable. 0 on success.\n\n:returns: the FPGA index", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getDutyCycleFPGAIndex"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "dutyCycleHandle", "type": "int"}], "tooltip": "Get the frequency of the duty cycle signal.\n\n:param in:  dutyCycleHandle the duty cycle handle\n:param out: status Error status variable. 0 on success.\n\n:returns: frequency in Hertz", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getDutyCycleFrequency"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "dutyCycleHandle", "type": "int"}], "tooltip": "Get the raw high time of the duty cycle signal.\n\n:param in:  dutyCycleHandle the duty cycle handle\n:param out: status Error status variable. 0 on success.\n\n:returns: high time of last pulse in nanoseconds", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getDutyCycleHighTime"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "dutyCycleHandle", "type": "int"}], "tooltip": "Get the output ratio of the duty cycle signal.\n\n0 means always low, 1 means always high.\n\n:param in:  dutyCycleHandle the duty cycle handle\n:param out: status Error status variable. 0 on success.\n\n:returns: output ratio between 0 and 1", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getDutyCycleOutput"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "dutyCycleHandle", "type": "int"}], "tooltip": "Get the scale factor of the output.\n\nAn output equal to this value is always high, and then linearly scales\ndown to 0. Divide a raw result by this in order to get the\npercentage between 0 and 1. Used by DMA.\n\n:param in:  dutyCycleHandle the duty cycle handle\n:param out: status Error status variable. 0 on success.\n\n:returns: the output scale factor", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getDutyCycleOutputScaleFactor"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "encoderHandle", "type": "int"}], "tooltip": "Gets the current counts of the encoder after encoding type scaling.\n\nThis is scaled by the value passed during initialization to encodingType.\n\n:param in:  encoderHandle the encoder handle\n:param out: status Error status variable. 0 on success.\n\n:returns: the current scaled count", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getEncoder"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "encoderHandle", "type": "int"}], "tooltip": "Gets the decoding scale factor of the encoder.\n\nThis is used to perform the scaling from raw to type scaled values.\n\n:param in:  encoderHandle the encoder handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: the scale value for the encoder", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getEncoderDecodingScaleFactor"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "encoderHandle", "type": "int"}], "tooltip": "Gets the last direction the encoder value changed.\n\n:param in:  encoderHandle the encoder handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: the last direction the encoder value changed", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getEncoderDirection"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "encoderHandle", "type": "int"}], "tooltip": "Gets the current distance traveled by the encoder.\n\nThis is the encoder count scaled by the distance per pulse set for the\nencoder.\n\n:param in:  encoderHandle the encoder handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: the encoder distance (units are determined by the units\n          passed to HAL_SetEncoderDistancePerPulse)", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getEncoderDistance"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "encoderHandle", "type": "int"}], "tooltip": "Gets the user set distance per pulse of the encoder.\n\n:param in:  encoderHandle the encoder handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: the set distance per pulse", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getEncoderDistancePerPulse"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "encoderHandle", "type": "int"}], "tooltip": "Gets the encoder scale value.\n\nThis is set by the value passed during initialization to encodingType.\n\n:param in:  encoderHandle the encoder handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: the encoder scale value", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getEncoderEncodingScale"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[hal._wpiHal.EncoderEncodingType, int]", "args": [{"name": "encoderHandle", "type": "int"}], "tooltip": "Gets the encoding type of the encoder.\n\n:param in:  encoderHandle the encoder handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: the encoding type", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getEncoderEncodingType"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "encoderHandle", "type": "int"}], "tooltip": "Gets the FPGA index of the encoder.\n\n:param in:  encoderHandle the encoder handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: the FPGA index of the encoder", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getEncoderFPGAIndex"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "encoderHandle", "type": "int"}], "tooltip": "Gets the Period of the most recent count.\n\nReturns the time interval of the most recent count. This can be used for\nvelocity calculations to determine shaft speed.\n\n:param in:  encoderHandle the encoder handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: the period of the last two pulses in units of seconds", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getEncoderPeriod"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "encoderHandle", "type": "int"}], "tooltip": "Gets the current rate of the encoder.\n\nThis is the encoder period scaled by the distance per pulse set for the\nencoder.\n\n:param in:  encoderHandle the encoder handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: the encoder rate (units are determined by the units passed to\n          HAL_SetEncoderDistancePerPulse, time value is seconds)", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getEncoderRate"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "encoderHandle", "type": "int"}], "tooltip": "Gets the raw counts of the encoder.\n\nThis is not scaled by any values.\n\n:param in:  encoderHandle the encoder handle\n:param out: status Error status variable. 0 on success.\n\n:returns: the raw encoder count", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getEncoderRaw"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "encoderHandle", "type": "int"}], "tooltip": "Gets the current samples to average value.\n\n:param in:  encoderHandle the encoder handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: the current samples to average value", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getEncoderSamplesToAverage"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "encoderHandle", "type": "int"}], "tooltip": "Determines if the clock is stopped.\n\nDetermines if the clocked input is stopped based on the MaxPeriod value set\nusing the SetMaxPeriod method. If the clock exceeds the MaxPeriod, then the\ndevice (and encoder) are assumed to be stopped and it returns true.\n\n:param in:  encoderHandle the encoder handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: true if the most recent encoder period exceeds the MaxPeriod value\n          set by SetMaxPeriod", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getEncoderStopped"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "str", "args": [{"name": "code", "type": "int"}], "tooltip": "Gets the error message for a specific status code.\n\n:param code: the status code\n\n:returns: the error message for the code. This does not need to be freed.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getErrorMessage"}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Gets the state of the \"USER\" button on the roboRIO.\n\n@warning the User Button is used to stop user programs from automatically\nloading if it is held for more then 5 seconds. Because of this, it's not\nrecommended to be used by teams for any other purpose.\n\n:param out: status the error code, or 0 for success\n\n:returns: true if the button is currently pressed down", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getFPGAButton"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Returns the FPGA Revision number.\n\nThe format of the revision is 3 numbers.\nThe 12 most significant bits are the Major Revision.\nthe next 8 bits are the Minor Revision.\nThe 12 least significant bits are the Build Number.\n\n:param out: status the error code, or 0 for success\n\n:returns: FPGA Revision number.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getFPGARevision"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Reads the microsecond-resolution timer on the FPGA.\n\n:param out: status the error code, or 0 for success\n\n:returns: The current time in microseconds according to the FPGA (since FPGA\n          reset).", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getFPGATime"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Returns the FPGA Version number.\n\nFor now, expect this to be competition year.\n\n:param out: status the error code, or 0 for success\n\n:returns: FPGA Version number.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getFPGAVersion"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "filterIndex", "type": "int"}], "tooltip": "Gets the filter period for the specified filter index.\n\nGets the filter period in FPGA cycles.  Even though there are 2 different\nfilter index domains (MXP vs HDR), ignore that distinction for now since it\ncomplicates the interface.  Set status to NiFpga_Status_SoftwareFault if the\nfilter values mismatch.\n\n:param in:  filterIndex the filter index, 0 - 2\n:param out: status     Error status variable. 0 on success.\n\n:returns: The number of FPGA cycles of the filter period.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getFilterPeriod"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "dioPortHandle", "type": "int"}], "tooltip": "Reads the filter index from the FPGA.\n\nGets the filter index used to filter out short pulses.\n\n:param in:  dioPortHandle the digital port handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: filterIndex  the filter index (Must be in the range 0 - 3, where 0\n          means \"none\" and 1 - 3 means filter # filterIndex - 1)", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getFilterSelect"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}], "tooltip": "Get the handle index from a handle.\n\n:param handle: the handle\n\n:returns: the index", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getHandleIndex"}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myHandleEnum"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "hal._wpiHal.HandleEnum", "args": [{"name": "handle", "type": "int"}], "tooltip": "Get the handle type from a handle.\n\n:param handle: the handle\n\n:returns: the type", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getHandleType"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "enumType", "type": "hal._wpiHal.HandleEnum"}, {"name": "version", "type": "int"}], "tooltip": "Get if the handle is a correct type and version.\n\nNote the version is not checked on the roboRIO.\n\n:param handle:   the handle\n:param enumType: the type to check\n:param version:  the handle version to check\n\n:returns: true if the handle is proper version and type, otherwise\n          false.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getHandleTypedIndex"}, "inputs": {"ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myHandleEnum"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "joystickNum", "type": "int"}, {"name": "axes", "type": "hal._wpiHal.JoystickAxes"}], "tooltip": "Gets the axes of a specific joystick.\n\n:param joystickNum: the joystick number\n:param axes:        the axes values (output)\n\n:returns: the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getJoystickAxes"}, "inputs": {"ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myJoystickAxes"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "joystickNum", "type": "int"}, {"name": "axis", "type": "int"}], "tooltip": "Gets the type of a specific joystick axis.\n\nThis is device specific, and different depending on what system input type\nthe joystick uses.\n\n:param joystickNum: the joystick number\n:param axis:        the axis number\n\n:returns: the enumerated axis type", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getJoystickAxisType"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "joystickNum", "type": "int"}, {"name": "buttons", "type": "hal._wpiHal.JoystickButtons"}], "tooltip": "Gets the buttons of a specific joystick.\n\n:param joystickNum: the joystick number\n:param buttons:     the button values (output)\n\n:returns: the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getJoystickButtons"}, "inputs": {"ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myJoystickButtons"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "joystickNum", "type": "int"}, {"name": "desc", "type": "hal._wpiHal.JoystickDescriptor"}], "tooltip": "Retrieves the Joystick Descriptor for particular slot.\n\n:param joystickNum: the joystick number\n:param out:         desc   descriptor (data transfer object) to fill in. desc is\n                    filled in regardless of success. In other words, if\n                    descriptor is not available, desc is filled in with\n                    default values matching the init-values in Java and C++\n                    Driver Station for when caller requests a too-large\n                    joystick index.\n\n:returns: error code reported from Network Comm back-end.  Zero is good,\n          nonzero is bad.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getJoystickDescriptor"}, "inputs": {"ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myJoystickDescriptor"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "joystickNum", "type": "int"}], "tooltip": "Gets whether a specific joystick is considered to be an XBox controller.\n\n:param joystickNum: the joystick number\n\n:returns: true if xbox, false otherwise", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getJoystickIsXbox"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "str", "args": [{"name": "joystickNum", "type": "int"}], "tooltip": "Gets the name of a joystick.\n\nThe returned string must be freed with WPI_FreeString\n\n:param name:        the joystick name string\n:param joystickNum: the joystick number", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getJoystickName"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "joystickNum", "type": "int"}, {"name": "povs", "type": "hal._wpiHal.JoystickPOVs"}], "tooltip": "Gets the POVs of a specific joystick.\n\n:param joystickNum: the joystick number\n:param povs:        the POV values (output)\n\n:returns: the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getJoystickPOVs"}, "inputs": {"ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myJoystickPOVs"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "joystickNum", "type": "int"}], "tooltip": "Gets the type of joystick connected.\n\nThis is device specific, and different depending on what system input type\nthe joystick uses.\n\n:param joystickNum: the joystick number\n\n:returns: the enumerated joystick type", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getJoystickType"}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[str, int]", "args": [], "tooltip": "Gets the last error set on this thread, or the message for the status code.\n\nIf passed HAL_USE_LAST_ERROR, the last error set on the thread will be\nreturned.\n\n:param out: status the status code, set to the error status code if input is\n            HAL_USE_LAST_ERROR\n\n:returns: the error message for the code. This does not need to be freed,\n          but can be overwritten by another hal call on the same thread.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getLastError"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "info", "type": "hal._wpiHal.MatchInfo"}], "tooltip": "Gets info about a specific match.\n\n:param in: info the match info (output)\n\n:returns: the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getMatchInfo"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myMatchInfo"}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [], "tooltip": "Return the approximate match time. The FMS does not send an official match\ntime to the robots, but does send an approximate match time. The value will\ncount down the time remaining in the current period (auto or teleop).\nWarning: This is not an official time (so it cannot be used to dispute ref\ncalls or guarantee that a function will trigger before the match ends).\n\nWhen connected to the real field, this number only changes in full integer\nincrements, and always counts down.\n\nWhen the DS is in practice mode, this number is a floating point number,\nand counts down.\n\nWhen the DS is in teleop or autonomous mode, this number is a floating\npoint number, and counts up.\n\nSimulation matches DS behavior without an FMS connected.\n\n:param out: status the error code, or 0 for success\n\n:returns: Time remaining in current match period (auto or teleop) in seconds", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getMatchTime"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of analog accumulators in the current system.\n\n:returns: the number of analog accumulators", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumAccumulators"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of addressable LED generators in the current system.\n\n:returns: the number of Addressable LED generators", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumAddressableLEDs"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of analog inputs in the current system.\n\n:returns: the number of analog inputs", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumAnalogInputs"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of analog outputs in the current system.\n\n:returns: the number of analog outputs", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumAnalogOutputs"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of analog triggers in the current system.\n\n:returns: the number of analog triggers", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumAnalogTriggers"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of PCM modules in the current system.\n\n:returns: the number of PCM modules", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumCTREPCMModules"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of PDP channels in the current system.\n\n:returns: the number of PDP channels", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumCTREPDPChannels"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of PDP modules in the current system.\n\n:returns: the number of PDP modules", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumCTREPDPModules"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of solenoid channels in the current system.\n\n:returns: the number of solenoid channels", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumCTRESolenoidChannels"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of counters in the current system.\n\n:returns: the number of counters", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumCounters"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of digital channels in the current system.\n\n:returns: the number of digital channels", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumDigitalChannels"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of digital headers in the current system.\n\n:returns: the number of digital headers", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumDigitalHeaders"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of digital IO PWM outputs in the current system.\n\n:returns: the number of digital IO PWM outputs", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumDigitalPWMOutputs"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of duty cycle inputs in the current system.\n\n:returns: the number of Duty Cycle inputs", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumDutyCycles"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of quadrature encoders in the current system.\n\n:returns: the number of quadrature encoders", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumEncoders"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of interrupts in the current system.\n\n:returns: the number of interrupts", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumInterrupts"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of PWM channels in the current system.\n\n:returns: the number of PWM channels", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumPWMChannels"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of PWM headers in the current system.\n\n:returns: the number of PWM headers", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumPWMHeaders"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of PDH channels in the current system.\n\n:returns: the number of PDH channels", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumREVPDHChannels"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of PDH modules in the current system.\n\n:returns: the number of PDH modules", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumREVPDHModules"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of PH channels in the current system.\n\n:returns: the number of PH channels", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumREVPHChannels"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of PH modules in the current system.\n\n:returns: the number of PH modules", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumREVPHModules"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of relay channels in the current system.\n\n:returns: the number of relay channels", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumRelayChannels"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of relay headers in the current system.\n\n:returns: the number of relay headers", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getNumRelayHeaders"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets if outputs are enabled by the control system.\n\n:returns: true if outputs are enabled", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getOutputsEnabled"}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int, int, int, int, int]", "args": [{"name": "pwmPortHandle", "type": "int"}], "tooltip": "Gets the pwm configuration settings for the PWM channel.\n\nValues are in microseconds.\n\n:param in:  pwmPortHandle  the PWM handle\n:param in:  maxPwm         the maximum PWM value\n:param in:  deadbandMaxPwm the high range of the center deadband\n:param in:  centerPwm      the center PWM value\n:param in:  deadbandMinPwm the low range of the center deadband\n:param in:  minPwm         the minimum PWM value\n:param out: status        Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPWMConfigMicroseconds"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Gets the pwm starting cycle time.\n\nThis time is relative to the FPGA time.\n\n:param out: status Error status variable. 0 on success.\n\n:returns: the pwm cycle start time", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPWMCycleStartTime"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "pwmPortHandle", "type": "int"}], "tooltip": "Gets the current eliminate deadband value.\n\n:param in:  pwmPortHandle the PWM handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: true if set, otherwise false", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPWMEliminateDeadband"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Gets the loop timing of the PWM system.\n\n:param out: status Error status variable. 0 on success.\n\n:returns: the loop time in clock ticks", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPWMLoopTiming"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "pwmPortHandle", "type": "int"}], "tooltip": "Gets a position value from a PWM channel.\n\nThe values range from 0 to 1.\n\n:param in:  pwmPortHandle the PWM handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: the current positional PWM value", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPWMPosition"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "pwmPortHandle", "type": "int"}], "tooltip": "Gets the current microsecond pulse time from a PWM channel.\n\n:param in:  pwmPortHandle the PWM handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: the current PWM microsecond pulse time", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPWMPulseTimeMicroseconds"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "pwmPortHandle", "type": "int"}], "tooltip": "Gets a scaled value from a PWM channel.\n\nThe values range from -1 to 1.\n\n:param in:  pwmPortHandle the PWM handle\n:param out: status       Error status variable. 0 on success.\n\n:returns: the current speed PWM value", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPWMSpeed"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "channel", "type": "int"}], "tooltip": "Gets a port handle for a specific channel.\n\nThe created handle does not need to be freed.\n\n:param channel: the channel number\n\n:returns: the created port", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPort"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}], "tooltip": "Gets the port channel of a port handle.\n\n:param handle: the port handle\n\n:returns: the port channel", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPortHandleChannel"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}], "tooltip": "Gets the port module of a port handle.\n\n:param handle: the port handle\n\n:returns: the port module", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPortHandleModule"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}], "tooltip": "Gets the SPI channel of a port handle.\n\n:param handle: the port handle\n\n:returns: the port SPI channel", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPortHandleSPIEnable"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "module", "type": "int"}, {"name": "channel", "type": "int"}], "tooltip": "Gets a port handle for a specific channel and module.\n\nThis is expected to be used for PCMs, as the roboRIO does not work with\nmodules anymore.\n\nThe created handle does not need to be freed.\n\n:param module:  the module number\n:param channel: the channel number\n\n:returns: the created port", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPortWithModule"}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "handle", "type": "int"}, {"name": "currentsLength", "type": "int"}], "tooltip": "Gets the current of all channels on the PowerDistribution.\n\nThe array must be large enough to hold all channels.\n\n:param in:  handle         the module handle\n:param out: currents      the currents\n:param in:  currentsLength the length of the currents array\n:param out: status        Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPowerDistributionAllChannelCurrents"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "handle", "type": "int"}, {"name": "channel", "type": "int"}], "tooltip": "Gets the current of a specific PowerDistribution channel.\n\n:param in:  handle   the module handle\n:param in:  channel  the channel\n:param out: status  Error status variable. 0 on success.\n\n:returns: the channel current (amps)", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPowerDistributionChannelCurrent"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "faults", "type": "hal._wpiHal.PowerDistributionFaults"}], "tooltip": "Get the current faults of the PowerDistribution.\n\nOn a CTRE PDP, this will return an object with no faults active.\n\n:param in:  handle the module handle\n:param out: faults the HAL_PowerDistributionFaults to populate\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPowerDistributionFaults"}, "inputs": {"ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myPowerDistributionFaults"}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Gets the module number for a specific handle.\n\n:param in:  handle the module handle\n:param out: status Error status variable. 0 on success.\n\n:returns: the module number", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPowerDistributionModuleNumber"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Gets the number of channels for this handle.\n\n:param in:  handle the handle\n:param out: status Error status variable. 0 on success.\n\n:returns: number of channels", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPowerDistributionNumChannels"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "stickyFaults", "type": "hal._wpiHal.PowerDistributionStickyFaults"}], "tooltip": "Gets the sticky faults of the PowerDistribution.\n\nOn a CTRE PDP, this will return an object with no faults active.\n\n:param in:  handle the module handle\n:param out: stickyFaults the HAL_PowerDistributionStickyFaults to populate\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPowerDistributionStickyFaults"}, "inputs": {"ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myPowerDistributionStickyFaults"}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Returns true if switchable channel is powered on.\n\nThis is a REV PDH-specific function. This function will no-op on CTRE PDP.\n\n:param in:  handle the module handle\n:param out: status Error status variable. 0 on success.\n\n:returns: the state of the switchable channel", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPowerDistributionSwitchableChannel"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Gets the temperature of the Power Distribution Panel.\n\nNot supported on the Rev PDH and returns 0.\n\n:param in:  handle the module handle\n:param out: status Error status variable. 0 on success.\n\n:returns: the module temperature (celsius)", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPowerDistributionTemperature"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Gets the total current of the PowerDistribution.\n\n:param in:  handle the module handle\n:param out: status Error status variable. 0 on success.\n\n:returns: the total current (amps)", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPowerDistributionTotalCurrent"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Gets the total energy of the Power Distribution Panel.\n\nNot supported on the Rev PDH and returns 0.\n\n:param in:  handle the module handle\n:param out: status Error status variable. 0 on success.\n\n:returns: the total energy (joules)", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPowerDistributionTotalEnergy"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Gets the total power of the Power Distribution Panel.\n\nNot supported on the Rev PDH and returns 0.\n\n:param in:  handle the module handle\n:param out: status Error status variable. 0 on success.\n\n:returns: the total power (watts)", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPowerDistributionTotalPower"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[hal._wpiHal.PowerDistributionType, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Gets the type of PowerDistribution module.\n\n:param in:  handle the module handle\n:param out: status Error status variable. 0 on success.\n\n:returns: the type of module", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPowerDistributionType"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "version", "type": "hal._wpiHal.PowerDistributionVersion"}], "tooltip": "Get the version of the PowerDistribution.\n\n:param in:  handle the module handle\n:param out: version the HAL_PowerDistributionVersion to populate\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPowerDistributionVersion"}, "inputs": {"ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myPowerDistributionVersion"}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Gets the PowerDistribution input voltage.\n\n:param in:  handle the module handle\n:param out: status Error status variable. 0 on success.\n\n:returns: the input voltage (volts)", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getPowerDistributionVoltage"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Returns the current voltage of the regulated 5v supply.\n\n:param in:  handle  the PH handle\n:param out: status Error status variable. 0 on success.\n\n:returns: The current voltage of the 5v supply in volts.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getREVPH5VVoltage"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "handle", "type": "int"}, {"name": "channel", "type": "int"}], "tooltip": "Returns the raw voltage of the specified analog\ninput channel.\n\n:param in:  handle  the PH handle\n:param in:  channel The analog input channel to read voltage from.\n:param out: status Error status variable. 0 on success.\n\n:returns: The voltage of the specified analog input channel in volts.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getREVPHAnalogVoltage"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Get whether compressor is turned on.\n\n:param in:  handle  the PH handle\n:param out: status Error status variable. 0 on success.\n\n:returns: true if the compressor is turned on", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getREVPHCompressor"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[hal._wpiHal.REVPHCompressorConfigType, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Get compressor configuration from the PH.\n\n:param in:  handle  the PH handle\n:param out: status Error status variable. 0 on success.\n\n:returns: compressor configuration", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getREVPHCompressorConfig"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Returns the current drawn by the compressor.\n\n:param in:  handle  the PH handle\n:param out: status Error status variable. 0 on success.\n\n:returns: The current drawn by the compressor in amps.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getREVPHCompressorCurrent"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "faults", "type": "hal._wpiHal.REVPHFaults"}], "tooltip": "Returns the faults currently active on the PH.\n\n:param in:  handle  the PH handle\n:param out: faults The faults.\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getREVPHFaults"}, "inputs": {"ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myREVPHFaults"}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Returns the state of the digital pressure switch.\n\n:param in:  handle  the PH handle\n:param out: status Error status variable. 0 on success.\n\n:returns: True if pressure switch indicates that the system is full,\n          otherwise false.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getREVPHPressureSwitch"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Returns the total current drawn by all solenoids.\n\n:param in:  handle  the PH handle\n:param out: status Error status variable. 0 on success.\n\n:returns: Total current drawn by all solenoids in amps.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getREVPHSolenoidCurrent"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Get a bitmask of disabled solenoids.\n\n:param in:  handle  the PH handle\n:param out: status Error status variable. 0 on success.\n\n:returns: Bitmask indicating disabled solenoids. The LSB represents solenoid 0.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getREVPHSolenoidDisabledList"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Returns the current voltage of the solenoid power supply.\n\n:param in:  handle  the PH handle\n:param out: status Error status variable. 0 on success.\n\n:returns: The current voltage of the solenoid power supply in volts.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getREVPHSolenoidVoltage"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Gets a bitmask of solenoid values.\n\n:param in:  handle  the PH handle\n:param out: status Error status variable. 0 on success.\n\n:returns: Bitmask containing the state of the solenoids. The LSB represents\n          solenoid 0.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getREVPHSolenoids"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "stickyFaults", "type": "hal._wpiHal.REVPHStickyFaults"}], "tooltip": "Returns the sticky faults currently active on this device.\n\n:param in:  handle  the PH handle\n:param out: stickyFaults The sticky faults.\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getREVPHStickyFaults"}, "inputs": {"ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myREVPHStickyFaults"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "version", "type": "hal._wpiHal.REVPHVersion"}], "tooltip": "Returns the hardware and firmware versions of the PH.\n\n:param in:  handle  the PH handle\n:param out: version The hardware and firmware versions.\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getREVPHVersion"}, "inputs": {"ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myREVPHVersion"}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Returns the current input voltage for the PH.\n\n:param in:  handle  the PH handle\n:param out: status Error status variable. 0 on success.\n\n:returns: The input voltage in volts.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getREVPHVoltage"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Gets the current state of the Robot Signal Light (RSL).\n\n:param out: status the error code, or 0 for success\n\n:returns: The current state of the RSL- true if on, false if off", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getRSLState"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "relayPortHandle", "type": "int"}], "tooltip": "Gets the current state of the relay channel.\n\n:param in:  relayPortHandle the relay handle\n:param out: status         Error status variable. 0 on success.\n\n:returns: true for on, false for off", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getRelay"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myRuntimeType"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "hal._wpiHal.RuntimeType", "args": [], "tooltip": "Returns the runtime type of the HAL.\n\n:returns: HAL Runtime Type", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getRuntimeType"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}], "tooltip": "Gets the count of how many SPI accumulations have been missed.\n\n:param in:  port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n            for MXP.\n:param out: status the error code, or 0 for success\n\n:returns: The number of missed accumulations.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getSPIAutoDroppedCount"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}], "tooltip": "Gets the stored handle for a SPI port.\n\n:param port: The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for MXP\n\n:returns: The stored handle for the SPI port. 0 represents no stored\n          handle.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getSPIHandle"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "mySPIMode"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "hal._wpiHal.SPIMode", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}], "tooltip": "Gets the SPI Mode.\n\n:param port: The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n             MXP\n\n:returns: The SPI mode currently set", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getSPIMode"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Gets the number of bytes currently in the read buffer.\n\n:param in:  handle  the serial port handle\n:param out: status the error code, or 0 for success\n\n:returns: the number of bytes in the read buffer", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getSerialBytesReceived"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}], "tooltip": "Gets the raw serial port file descriptor from a handle.\n\n:param in:  handle the serial port handle\n:param out: status the error code, or 0 for success\n\n:returns: the raw port descriptor", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getSerialFD"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "str", "args": [], "tooltip": "Returns the roboRIO serial number.\n\n:param out: serialNumber The roboRIO serial number. Free with WPI_FreeString", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getSerialNumber"}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Gets if the system outputs are currently active.\n\n:param out: status the error code, or 0 for success\n\n:returns: true if the system outputs are active, false if disabled", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getSystemActive"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Gets the number of FPGA system clock ticks per microsecond.\n\n:returns: the number of clock ticks per microsecond", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getSystemClockTicksPerMicrosecond"}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Gets if the system time is valid.\n\n:param out: status the error code, or 0 for success\n\n:returns: True if the system time is valid, false otherwise", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getSystemTimeValid"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Returns the team number configured for the robot controller.\n\n:returns: team number, or 0 if not found.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getTeamNumber"}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Gets the active state of the 3V3 rail.\n\n:param out: status the error code, or 0 for success\n\n:returns: true if the rail is active, otherwise false", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getUserActive3V3"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Gets the active state of the 5V rail.\n\n:param out: status the error code, or 0 for success\n\n:returns: true if the rail is active, otherwise false", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getUserActive5V"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Gets the active state of the 6V rail.\n\n:param out: status the error code, or 0 for success\n\n:returns: true if the rail is active, otherwise false", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getUserActive6V"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [], "tooltip": "Gets the 3V3 rail current.\n\n:param out: status the error code, or 0 for success\n\n:returns: the 3V3 rail current (amps)", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getUserCurrent3V3"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [], "tooltip": "Gets the 5V rail current.\n\n:param out: status the error code, or 0 for success\n\n:returns: the 5V rail current (amps)", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getUserCurrent5V"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [], "tooltip": "Gets the 6V rail current.\n\n:param out: status the error code, or 0 for success\n\n:returns: the 6V rail current (amps)", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getUserCurrent6V"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Gets the fault count for the 3V3 rail. Capped at 255.\n\n:param out: status the error code, or 0 for success\n\n:returns: the number of 3V3 fault counts", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getUserCurrentFaults3V3"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Gets the fault count for the 5V rail. Capped at 255.\n\n:param out: status the error code, or 0 for success\n\n:returns: the number of 5V fault counts", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getUserCurrentFaults5V"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Gets the fault count for the 6V rail. Capped at 255.\n\n:param out: status the error code, or 0 for success\n\n:returns: the number of 6V fault counts", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getUserCurrentFaults6V"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [], "tooltip": "Gets the 3V3 rail voltage.\n\n:param out: status the error code, or 0 for success\n\n:returns: the 3V3 rail voltage (volts)", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getUserVoltage3V3"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [], "tooltip": "Gets the 5V rail voltage.\n\n:param out: status the error code, or 0 for success\n\n:returns: the 5V rail voltage (volts)", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getUserVoltage5V"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [], "tooltip": "Gets the 6V rail voltage.\n\n:param out: status the error code, or 0 for success\n\n:returns: the 6V rail voltage (volts)", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getUserVoltage6V"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [], "tooltip": "Gets the roboRIO input current.\n\n:param out: status the error code, or 0 for success\n\n:returns: the input current (amps)", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getVinCurrent"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[float, int]", "args": [], "tooltip": "Gets the roboRIO input voltage.\n\n:param out: status the error code, or 0 for success\n\n:returns: the input voltage (volts)", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "getVinVoltage"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Returns true if HAL_SetMain() has been called.\n\n:returns: True if HAL_SetMain() has been called, false otherwise.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "hasMain"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "analogPortHandle", "type": "int"}], "tooltip": "Initialize the accumulator.\n\n:param in:  analogPortHandle Handle to the analog port.\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initAccumulator"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}, {"name": "bufferSize", "type": "int"}], "tooltip": "Initializes the SPI automatic accumulator.\n\n:param in:  port       The number of the port to use. 0-3 for Onboard CS0-CS2,\n            4 for MXP.\n:param in:  bufferSize The accumulator buffer size.\n:param out: status    the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initSPIAuto"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "timeout", "type": "int"}, {"name": "mode", "type": "int"}], "tooltip": "Call this to start up HAL. This is required for robot programs.\n\nThis must be called before any other HAL functions. Failure to do so will\nresult in undefined behavior, and likely segmentation faults. This means that\nany statically initialized variables in a program MUST call this function in\ntheir constructors if they want to use other HAL calls.\n\nThe common parameters are 500 for timeout and 0 for mode.\n\nThis function is safe to call from any thread, and as many times as you wish.\nIt internally guards from any reentrancy.\n\nThe applicable modes are:\n0: Try to kill an existing HAL from another program, if not successful,\nerror.\n1: Force kill a HAL from another program.\n2: Just warn if another hal exists and cannot be killed. Will likely result\nin undefined behavior.\n\n:param timeout: the initialization timeout (ms)\n:param mode:    the initialization mode (see remarks)\n\n:returns: true if initialization was successful, otherwise false.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initialize"}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "outputPort", "type": "int"}], "tooltip": "Initialize Addressable LED using a PWM Digital handle.\n\n:param in:  outputPort handle of the digital port for PWM\n:param out: status the error code, or 0 for success\n\n:returns: Addressable LED handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializeAddressableLED"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}, {"name": "allocationLocation", "type": "str"}], "tooltip": "Initializes an analog gyro.\n\n:param in:  handle handle to the analog input port\n:param in:  allocationLocation the location where the allocation is occurring\n            (can be null)\n:param out: status the error code, or 0 for success\n\n:returns: the initialized gyro handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializeAnalogGyro"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "portHandle", "type": "int"}, {"name": "allocationLocation", "type": "str"}], "tooltip": "Initializes the analog input port using the given port object.\n\n:param in:  portHandle Handle to the port to initialize.\n:param in:  allocationLocation the location where the allocation is occurring\n            (can be null)\n:param out: status the error code, or 0 for success\n\n:returns: the created analog input handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializeAnalogInputPort"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "portHandle", "type": "int"}, {"name": "allocationLocation", "type": "str"}], "tooltip": "Initializes the analog output port using the given port object.\n\n:param in:  portHandle handle to the port\n:param in:  allocationLocation the location where the allocation is occurring\n            (can be null)\n:param out: status Error status variable. 0 on success.\n\n:returns: the created analog output handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializeAnalogOutputPort"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "portHandle", "type": "int"}], "tooltip": "Initializes an analog trigger.\n\n:param in:  portHandle the analog input to use for triggering\n:param out: status     Error status variable. 0 on success.\n\n:returns: the created analog trigger handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializeAnalogTrigger"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "dutyCycleHandle", "type": "int"}], "tooltip": "Initializes an analog trigger with a Duty Cycle input\n\n:param in:  dutyCycleHandle the analog input to use for duty cycle\n:param out: status          Error status variable. 0 on success.\n\n:returns: tbe created analog trigger handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializeAnalogTriggerDutyCycle"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "manufacturer", "type": "hal._wpiHal.CANManufacturer"}, {"name": "deviceId", "type": "int"}, {"name": "deviceType", "type": "hal._wpiHal.CANDeviceType"}], "tooltip": "Initializes a CAN device.\n\nThese follow the FIRST standard CAN layout.\nhttps://docs.wpilib.org/en/stable/docs/software/can-devices/can-addressing.html\n\n:param in:  manufacturer the can manufacturer\n:param in:  deviceId     the device ID (0-63)\n:param in:  deviceType   the device type\n:param out: status      Error status variable. 0 on success.\n\n:returns: the created CAN handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializeCAN"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myCANManufacturer"}}}}, "ARG2": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myCANDeviceType"}}}}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "module", "type": "int"}, {"name": "allocationLocation", "type": "str"}], "tooltip": "Initializes a PCM.\n\n:param in:  module             the CAN ID to initialize\n:param in:  allocationLocation the location where the allocation is occurring\n            (can be null)\n:param out: status            Error status variable. 0 on success.\n\n:returns: the created PH handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializeCTREPCM"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int, int]", "args": [{"name": "mode", "type": "hal._wpiHal.CounterMode"}], "tooltip": "Initializes a counter.\n\n:param in:  mode    the counter mode\n:param in:  index   the compressor index (output)\n:param out: status Error status variable. 0 on success.\n\n:returns: the created handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializeCounter"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myCounterMode"}}}}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "portHandle", "type": "int"}, {"name": "input", "type": "int"}, {"name": "allocationLocation", "type": "str"}], "tooltip": "Creates a new instance of a digital port.\n\n:param in:  portHandle         the port handle to create from\n:param in:  input              true for input, false for output\n:param in:  allocationLocation the location where the allocation is occurring\n            (can be null)\n:param out: status            Error status variable. 0 on success.\n\n:returns: the created digital handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializeDIOPort"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "digitalSourceHandle", "type": "int"}, {"name": "triggerType", "type": "hal._wpiHal.AnalogTriggerType"}], "tooltip": "Initialize a DutyCycle input.\n\n:param in:  digitalSourceHandle the digital source to use (either a\n            HAL_DigitalHandle or a\n            HAL_AnalogTriggerHandle)\n:param in:  triggerType the analog trigger type of the source if it is\n            an analog trigger\n:param out: status Error status variable. 0 on success.\n\n:returns: the created duty cycle handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializeDutyCycle"}, "inputs": {"ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogTriggerType"}}}}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "digitalSourceHandleA", "type": "int"}, {"name": "analogTriggerTypeA", "type": "hal._wpiHal.AnalogTriggerType"}, {"name": "digitalSourceHandleB", "type": "int"}, {"name": "analogTriggerTypeB", "type": "hal._wpiHal.AnalogTriggerType"}, {"name": "reverseDirection", "type": "int"}, {"name": "encodingType", "type": "hal._wpiHal.EncoderEncodingType"}], "tooltip": "Initializes an encoder.\n\n:param in:  digitalSourceHandleA the A source (either a HAL_DigitalHandle or a\n            HAL_AnalogTriggerHandle)\n:param in:  analogTriggerTypeA   the analog trigger type of the A source if it\n            is an analog trigger\n:param in:  digitalSourceHandleB the B source (either a HAL_DigitalHandle or a\n            HAL_AnalogTriggerHandle)\n:param in:  analogTriggerTypeB   the analog trigger type of the B source if it\n            is an analog trigger\n:param in:  reverseDirection     true to reverse the counting direction from\n            standard, otherwise false\n:param in:  encodingType         the encoding type\n:param out: status              Error status variable. 0 on success.\n\n:returns: the created encoder handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializeEncoder"}, "inputs": {"ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogTriggerType"}}}}, "ARG3": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogTriggerType"}}}}, "ARG5": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myEncoderEncodingType"}}}}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "port", "type": "hal._wpiHal.I2CPort"}], "tooltip": "Initializes the I2C port.\n\nOpens the port if necessary and saves the handle.\nIf opening the MXP port, also sets up the channel functions appropriately.\n\n:param in:  port    The port to open, 0 for the on-board, 1 for the MXP.\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializeI2C"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myI2CPort"}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Initializes an interrupt.\n\n:param out: status Error status variable. 0 on success.\n\n:returns: the created interrupt handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializeInterrupts"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Initializes a notifier.\n\nA notifier is an FPGA controller timer that triggers at requested intervals\nbased on the FPGA time. This can be used to make precise control loops.\n\n:param out: status Error status variable. 0 on success.\n\n:returns: the created notifier", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializeNotifier"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "portHandle", "type": "int"}, {"name": "allocationLocation", "type": "str"}], "tooltip": "Initializes a PWM port.\n\n:param in:  portHandle the port to initialize\n:param in:  allocationLocation  the location where the allocation is occurring\n            (can be null)\n:param out: status             Error status variable. 0 on success.\n\n:returns: the created pwm handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializePWMPort"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "moduleNumber", "type": "int"}, {"name": "type", "type": "hal._wpiHal.PowerDistributionType"}, {"name": "allocationLocation", "type": "str"}], "tooltip": "Initializes a Power Distribution Panel.\n\n:param in:  moduleNumber       the module number to initialize\n:param in:  type               the type of module to initialize\n:param in:  allocationLocation the location where the allocation is occurring\n:param out: status            Error status variable. 0 on success.\n\n:returns: the created PowerDistribution handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializePowerDistribution"}, "inputs": {"ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myPowerDistributionType"}}}}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "module", "type": "int"}, {"name": "allocationLocation", "type": "str"}], "tooltip": "Initializes a PH.\n\n:param in:  module             the CAN ID to initialize\n:param in:  allocationLocation the location where the allocation is occurring\n            (can be null)\n:param out: status            Error status variable. 0 on success.\n\n:returns: the created PH handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializeREVPH"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "portHandle", "type": "int"}, {"name": "fwd", "type": "int"}, {"name": "allocationLocation", "type": "str"}], "tooltip": "Initializes a relay.\n\nNote this call will only initialize either the forward or reverse port of the\nrelay. If you need both, you will need to initialize 2 relays.\n\n:param in:  portHandle         the port handle to initialize\n:param in:  fwd                true for the forward port, false for the\n            reverse port\n:param in:  allocationLocation the location where the allocation is occurring\n            (can be null)\n:param out: status            Error status variable. 0 on success.\n\n:returns: the created relay handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializeRelayPort"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}], "tooltip": "Initializes the SPI port. Opens the port if necessary and saves the handle.\n\nIf opening the MXP port, also sets up the channel functions appropriately.\n\n:param in:  port    The number of the port to use. 0-3 for Onboard CS0-CS3, 4\n            for MXP\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializeSPI"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "port", "type": "hal._wpiHal.SerialPort"}], "tooltip": "Initializes a serial port.\n\nThe channels are either the onboard RS232, the MXP UART, or 2 USB ports. The\ntop port is USB1, the bottom port is USB2.\n\n:param in:  port the serial port to initialize\n:param out: status the error code, or 0 for success\n\n:returns: Serial Port Handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializeSerialPort"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySerialPort"}}}}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "port", "type": "hal._wpiHal.SerialPort"}, {"name": "portName", "type": "str"}], "tooltip": "Initializes a serial port with a direct name.\n\nThis name is the /dev name for a specific port.\nNote these are not always consistent between roboRIO reboots.\n\n:param in:  port     the serial port to initialize\n:param in:  portName the dev port name\n:param out: status  the error code, or 0 for success\n\n:returns: Serial Port Handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "initializeSerialPortDirect"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySerialPort"}}}}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "analogPortHandle", "type": "int"}], "tooltip": "Is the channel attached to an accumulator.\n\n:param in:  analogPortHandle Handle to the analog port.\n:param out: status Error status variable. 0 on success.\n\n:returns: The analog channel is attached to an accumulator.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "isAccumulatorChannel"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [], "tooltip": "Checks if any DIO line is currently generating a pulse.\n\n:param out: status Error status variable. 0 on success.\n\n:returns: true if a pulse on some line is in progress", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "isAnyPulsing"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "bool", "args": [{"name": "handle", "type": "int"}, {"name": "version", "type": "int"}], "tooltip": "Get if the version of the handle is correct.\n\nDo not use on the roboRIO, used specifically for the sim to handle resets.\n\n:param handle:  the handle\n:param version: the handle version to check\n\n:returns: true if the handle is the right version, otherwise false", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "isHandleCorrectVersion"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "bool", "args": [{"name": "handle", "type": "int"}, {"name": "handleType", "type": "hal._wpiHal.HandleEnum"}], "tooltip": "Get if the handle is a specific type.\n\n:param handle:     the handle\n:param handleType: the type to check\n\n:returns: true if the type is correct, otherwise false", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "isHandleType"}, "inputs": {"ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myHandleEnum"}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "dioPortHandle", "type": "int"}], "tooltip": "Checks a DIO line to see if it is currently generating a pulse.\n\n:param in:  dioPortHandle the digital port handle\n:param out: status Error status variable. 0 on success.\n\n:returns: true if a pulse is in progress, otherwise false", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "isPulsing"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "pwmPortHandle", "type": "int"}], "tooltip": "Forces a PWM signal to go to 0 temporarily.\n\n:param in:  pwmPortHandle the PWM handle.\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "latchPWMZero"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Loads any extra halsim libraries provided in the HALSIM_EXTENSIONS\nenvironment variable.\n\n:returns: the success state of the initialization", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "loadExtensions"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "library", "type": "str"}], "tooltip": "Loads a single extension from a direct path.\n\nExpected to be called internally, not by users.\n\n:param library: the library path\n\n:returns: the success state of the initialization", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "loadOneExtension"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [], "tooltip": "Sets the autonomous enabled flag in the DS.\n\nThis is used for the DS to ensure the robot is properly responding to its\nstate request. Ensure this gets called about every 50ms, or the robot will be\ndisabled by the DS.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "observeUserProgramAutonomous"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [], "tooltip": "Sets the disabled flag in the DS.\n\nThis is used for the DS to ensure the robot is properly responding to its\nstate request. Ensure this gets called about every 50ms, or the robot will be\ndisabled by the DS.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "observeUserProgramDisabled"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [], "tooltip": "Sets the program starting flag in the DS.\n\nThis is what changes the DS to showing robot code ready.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "observeUserProgramStarting"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [], "tooltip": "Sets the teleoperated enabled flag in the DS.\n\nThis is used for the DS to ensure the robot is properly responding to its\nstate request. Ensure this gets called about every 50ms, or the robot will be\ndisabled by the DS.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "observeUserProgramTeleop"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [], "tooltip": "Sets the test mode flag in the DS.\n\nThis is used for the DS to ensure the robot is properly responding to its\nstate request. Ensure this gets called about every 50ms, or the robot will be\ndisabled by the DS.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "observeUserProgramTest"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "handle", "type": "int"}], "tooltip": "Adds an event handle to be signalled when new data arrives.\n\n:param handle: the event handle to be signalled", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "provideNewDataEventHandle"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "dioPortHandle", "type": "int"}, {"name": "pulseLengthSeconds", "type": "float"}], "tooltip": "Generates a single digital pulse.\n\nWrite a pulse to the specified digital output channel. There can only be a\nsingle pulse going at any time.\n\n:param in:  dioPortHandle the digital port handle\n:param in:  pulseLengthSeconds   the active length of the pulse (in seconds)\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "pulse"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "channelMask", "type": "int"}, {"name": "pulseLengthSeconds", "type": "float"}], "tooltip": "Generates a single digital pulse on multiple channels.\n\nWrite a pulse to the channels enabled by the mask. There can only be a\nsingle pulse going at any time.\n\n:param in:  channelMask the channel mask\n:param in:  pulseLengthSeconds   the active length of the pulse (in seconds)\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "pulseMultiple"}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int, int]", "args": [{"name": "handle", "type": "int"}, {"name": "apiId", "type": "int"}, {"name": "data", "type": "Buffer"}], "tooltip": "Reads a CAN packet. The will continuously return the last packet received,\nwithout accounting for packet age.\n\n:param in:  handle             the CAN handle\n:param in:  apiId              the ID to read (0-1023)\n:param out: data              the packet data (8 bytes)\n:param out: length            the received length (0-8 bytes)\n:param out: receivedTimestamp the packet received timestamp in ms (based off\n            of CLOCK_MONOTONIC)\n:param out: status            Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "readCANPacketLatest"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int, int]", "args": [{"name": "handle", "type": "int"}, {"name": "apiId", "type": "int"}, {"name": "data", "type": "Buffer"}], "tooltip": "Reads a new CAN packet.\n\nThis will only return properly once per packet received. Multiple calls\nwithout receiving another packet will return an error code.\n\n:param in:  handle             the CAN handle\n:param in:  apiId              the ID to read (0-1023)\n:param out: data              the packet data (8 bytes)\n:param out: length            the received length (0-8 bytes)\n:param out: receivedTimestamp the packet received timestamp in ms (based off\n            of CLOCK_MONOTONIC)\n:param out: status            Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "readCANPacketNew"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int, int]", "args": [{"name": "handle", "type": "int"}, {"name": "apiId", "type": "int"}, {"name": "data", "type": "Buffer"}, {"name": "timeoutMs", "type": "int"}], "tooltip": "Reads a CAN packet. The will return the last packet received until the\npacket is older then the requested timeout. Then it will return an error\ncode.\n\n:param in:  handle             the CAN handle\n:param in:  apiId              the ID to read (0-1023)\n:param out: data              the packet data (8 bytes)\n:param out: length            the received length (0-8 bytes)\n:param out: receivedTimestamp the packet received timestamp in ms (based off\n            of CLOCK_MONOTONIC)\n:param out: timeoutMs         the timeout time for the packet\n:param out: status            Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "readCANPacketTimeout"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "port", "type": "hal._wpiHal.I2CPort"}, {"name": "deviceAddress", "type": "int"}, {"name": "buffer", "type": "Buffer"}], "tooltip": "Executes a read transaction with the device.\n\nReads bytes from a device.\nMost I2C devices will auto-increment the register pointer internally allowing\nyou to read consecutive registers on a device in a single transaction.\n\n:param port:          The I2C port, 0 for the on-board, 1 for the MXP.\n:param deviceAddress: The register to read first in the transaction.\n:param count:         The number of bytes to read in the transaction.\n:param buffer:        A pointer to the array of bytes to store the data read from the\n                      device.\n\n:returns: 0 on success or -1 on transfer abort.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "readI2C"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myI2CPort"}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "interruptHandle", "type": "int"}], "tooltip": "Returns the timestamp for the falling interrupt that occurred most recently.\n\nThis is in the same time domain as HAL_GetFPGATime().  It only contains the\nbottom 32 bits of the timestamp.  If your robot has been running for over 1\nhour, you will need to fill in the upper 32 bits yourself.\n\n:param in:  interruptHandle the interrupt handle\n:param out: status         Error status variable. 0 on success.\n\n:returns: timestamp in microseconds since FPGA Initialization", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "readInterruptFallingTimestamp"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "interruptHandle", "type": "int"}], "tooltip": "Returns the timestamp for the rising interrupt that occurred most recently.\n\nThis is in the same time domain as HAL_GetFPGATime().  It only contains the\nbottom 32 bits of the timestamp.  If your robot has been running for over 1\nhour, you will need to fill in the upper 32 bits yourself.\n\n:param in:  interruptHandle the interrupt handle\n:param out: status         Error status variable. 0 on success.\n\n:returns: timestamp in microseconds since FPGA Initialization", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "readInterruptRisingTimestamp"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}, {"name": "buffer", "type": "Buffer"}], "tooltip": "Executes a read from the device.\n\nThis method does not write any data out to the device.\n\nMost spi devices will require a register address to be written before they\nbegin returning data.\n\n:param port:   The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n               MXP\n:param buffer: A pointer to the array of bytes to store the data read from the\n               device.\n:param count:  The number of bytes to read in the transaction. [1..7]\n\n:returns: Number of bytes read. -1 for error.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "readSPI"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}, {"name": "buffer", "type": "Buffer"}, {"name": "timeout", "type": "float"}], "tooltip": "Reads data received by the SPI accumulator.  Each received data sequence\nconsists of a timestamp followed by the received data bytes, one byte per\nword (in the least significant byte).  The length of each received data\nsequence is the same as the combined dataSize + zeroSize set in\nHAL_SetSPIAutoTransmitData.\n\n:param in:  port      The number of the port to use. 0-3 for Onboard CS0-CS2,\n            4 for MXP.\n:param out: buffer   The buffer to store the data into.\n:param in:  numToRead The number of words to read.\n:param in:  timeout   The read timeout (in seconds).\n:param out: status   the error code, or 0 for success\n\n:returns: The number of words actually read.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "readSPIAutoReceivedData"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}, {"name": "buffer", "type": "Buffer"}], "tooltip": "Reads data from the serial port.\n\nWill wait for either timeout (if set), the termination char (if set), or the\ncount to be full. Whichever one comes first.\n\n:param in:  handle  the serial port handle\n:param out: buffer the buffer in which to store bytes read\n:param in:  count   the number of bytes maximum to read\n:param out: status the error code, or 0 for success\n\n:returns: the number of bytes actually read", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "readSerial"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Refresh the DS control word.\n\n:returns: true if updated", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "refreshDSData"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "interruptHandle", "type": "int"}], "tooltip": "Releases a waiting interrupt.\n\nThis will release both rising and falling waiters.\n\n:param in:  interruptHandle the interrupt handle to release\n:param out: status         Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "releaseWaitingInterrupt"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "handle", "type": "int"}], "tooltip": "Removes the event handle from being signalled when new data arrives.\n\n:param handle: the event handle to remove", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "removeNewDataEventHandle"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "resource", "type": "int"}, {"name": "instanceNumber", "type": "int"}, {"name": "context", "type": "int"}, {"name": "feature", "type": "str"}], "tooltip": "Reports a hardware usage to the HAL.\n\n:param resource:       the used resource\n:param instanceNumber: the instance of the resource\n:param context:        a user specified context index\n:param feature:        a user specified feature string\n\n:returns: the index of the added value in NetComm", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "report"}, "inputs": {"ARG2": {"shadow": {"type": "math_number", "fields": {"NUM": 0.0}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "interruptHandle", "type": "int"}, {"name": "digitalSourceHandle", "type": "int"}, {"name": "analogTriggerType", "type": "hal._wpiHal.AnalogTriggerType"}], "tooltip": "Requests interrupts on a specific digital source.\n\n:param in:  interruptHandle     the interrupt handle\n:param in:  digitalSourceHandle the digital source handle (either a\n            HAL_AnalogTriggerHandle or a\n            HAL_DigitalHandle)\n:param in:  analogTriggerType   the trigger type if the source is an\n            AnalogTrigger\n:param out: status             Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "requestInterrupts"}, "inputs": {"ARG2": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogTriggerType"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "analogPortHandle", "type": "int"}], "tooltip": "Resets the accumulator to the initial value.\n\n:param in:  analogPortHandle Handle to the analog port.\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "resetAccumulator"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}], "tooltip": "Resets the analog gyro value to 0.\n\n:param in:  handle the gyro handle\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "resetAnalogGyro"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "counterHandle", "type": "int"}], "tooltip": "Resets the Counter to zero.\n\nSets the counter value to zero. This does not effect the running state of the\ncounter, just sets the current value to zero.\n\n:param in:  counterHandle the counter handle\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "resetCounter"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "encoderHandle", "type": "int"}], "tooltip": "Reads the current encoder value.\n\nRead the value at this instant. It may still be running, so it reflects the\ncurrent value. Next time it is read, it might have a different value.\n\n:param in:  encoderHandle the encoder handle\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "resetEncoder"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}], "tooltip": "Resets the PowerDistribution accumulated energy.\n\nNot supported on the Rev PDH and does nothing.\n\n:param in:  handle the module handle\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "resetPowerDistributionTotalEnergy"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [], "tooltip": "Resets the overcurrent fault counters for all user rails to 0.\n\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "resetUserCurrentFaults"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [], "tooltip": "Runs the main function provided to HAL_SetMain().\n\nIf HAL_SetMain() has not been called, simply sleeps until HAL_ExitMain()\nis called.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "runMain"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "line", "type": "str"}], "tooltip": "Sends a line to the driver station console.\n\n:param line: the line to send (null terminated)\n\n:returns: the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "sendConsoleLine"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "isError", "type": "int"}, {"name": "errorCode", "type": "int"}, {"name": "isLVCode", "type": "int"}, {"name": "details", "type": "str"}, {"name": "location", "type": "str"}, {"name": "callStack", "type": "str"}, {"name": "printMsg", "type": "int"}], "tooltip": "Sends an error to the driver station.\n\n:param isError:   true for error, false for warning\n:param errorCode: the error code\n:param isLVCode:  true for a LV error code, false for a standard error code\n:param details:   the details of the error\n:param location:  the file location of the error\n:param callStack: the callstack of the error\n:param printMsg:  true to print the error message to stdout as well as to the\n                  DS\n\n:returns: the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "sendError"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "active", "type": "int"}], "tooltip": "Sets the accelerometer to active or standby mode.\n\nIt must be in standby mode to change any configuration.\n\n:param active: true to set to active, false for standby", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAccelerometerActive"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "range", "type": "hal._wpiHal.AccelerometerRange"}], "tooltip": "Sets the range of values that can be measured (either 2, 4, or 8 g-forces).\n\nThe accelerometer should be in standby mode when this is called.\n\n:param range: the accelerometer range", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAccelerometerRange"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAccelerometerRange"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "analogPortHandle", "type": "int"}, {"name": "center", "type": "int"}], "tooltip": "Set the center value of the accumulator.\n\nThe center value is subtracted from each A/D value before it is added to the\naccumulator. This is used for the center value of devices like gyros and\naccelerometers to make integration work and to take the device offset into\naccount when integrating.\n\nThis center value is based on the output of the oversampled and averaged\nsource from channel 1. Because of this, any non-zero oversample bits will\naffect the size of the value for this field.\n\n:param in:  analogPortHandle Handle to the analog port.\n:param in:  center The center value of the accumulator.\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAccumulatorCenter"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "analogPortHandle", "type": "int"}, {"name": "deadband", "type": "int"}], "tooltip": "Set the accumulator's deadband.\n\n:param in:  analogPortHandle Handle to the analog port.\n:param in:  deadband The deadband of the accumulator.\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAccumulatorDeadband"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "highTime0NanoSeconds", "type": "int"}, {"name": "lowTime0NanoSeconds", "type": "int"}, {"name": "highTime1NanoSeconds", "type": "int"}, {"name": "lowTime1NanoSeconds", "type": "int"}], "tooltip": "Sets the bit timing.\n\nBy default, the driver is set up to drive WS2812Bs, so nothing needs to\nbe set for those.\n\n:param in:  handle the Addressable LED handle\n:param in:  highTime0NanoSeconds high time for 0 bit (default 400ns)\n:param in:  lowTime0NanoSeconds low time for 0 bit (default 900ns)\n:param in:  highTime1NanoSeconds high time for 1 bit (default 900ns)\n:param in:  lowTime1NanoSeconds low time for 1 bit (default 600ns)\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAddressableLEDBitTiming"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "length", "type": "int"}], "tooltip": "Sets the length of the LED strip.\n\nThe max length is 5460 LEDs.\n\n:param in:  handle the Addressable LED handle\n:param in:  length the strip length\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAddressableLEDLength"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "outputPort", "type": "int"}], "tooltip": "Set the Addressable LED PWM Digital port.\n\n:param in:  handle the Addressable LED handle\n:param in:  outputPort The digital handle of the PWM port\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAddressableLEDOutputPort"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "syncTimeMicroSeconds", "type": "int"}], "tooltip": "Sets the sync time.\n\nThe sync time is the time to hold output so LEDs enable. Default set for\nWS2812B.\n\n:param in:  handle the Addressable LED handle\n:param in:  syncTimeMicroSeconds the sync time (default 280us)\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAddressableLEDSyncTime"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "analogPortHandle", "type": "int"}, {"name": "bits", "type": "int"}], "tooltip": "Sets the number of averaging bits.\n\nThis sets the number of averaging bits. The actual number of averaged samples\nis 2**bits. Use averaging to improve the stability of your measurement at the\nexpense of sampling rate. The averaging is done automatically in the FPGA.\n\n:param in:  analogPortHandle Handle to the analog port to configure.\n:param in:  bits Number of bits to average.\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAnalogAverageBits"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "volts", "type": "float"}], "tooltip": "Sets the deadband of the analog gyro.\n\n:param in:  handle the gyro handle\n:param in:  volts  the voltage deadband\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAnalogGyroDeadband"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "voltsPerDegreePerSecond", "type": "float"}, {"name": "offset", "type": "float"}, {"name": "center", "type": "int"}], "tooltip": "Sets the analog gyro parameters to the specified values.\n\nThis is meant to be used if you want to reuse the values from a previous\ncalibration.\n\n:param in:  handle                  the gyro handle\n:param in:  voltsPerDegreePerSecond the gyro volts scaling\n:param in:  offset                  the gyro offset\n:param in:  center                  the gyro center\n:param out: status                  the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAnalogGyroParameters"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "voltsPerDegreePerSecond", "type": "float"}], "tooltip": "Sets the analog gyro volts per degrees per second scaling.\n\n:param in:  handle                  the gyro handle\n:param in:  voltsPerDegreePerSecond the gyro volts scaling\n:param out: status                  the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAnalogGyroVoltsPerDegreePerSecond"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "handle", "type": "int"}, {"name": "device", "type": "int"}], "tooltip": "Indicates the analog input is used by a simulated device.\n\n:param handle: the analog input handle\n:param device: simulated device handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAnalogInputSimDevice"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "analogOutputHandle", "type": "int"}, {"name": "voltage", "type": "float"}], "tooltip": "Sets an analog output value.\n\n:param in:  analogOutputHandle the analog output handle\n:param in:  voltage            the voltage (0-5v) to output\n:param out: status            Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAnalogOutput"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "analogPortHandle", "type": "int"}, {"name": "bits", "type": "int"}], "tooltip": "Sets the number of oversample bits.\n\nThis sets the number of oversample bits. The actual number of oversampled\nvalues is 2**bits. Use oversampling to improve the resolution of your\nmeasurements at the expense of sampling rate. The oversampling is done\nautomatically in the FPGA.\n\n:param in:  analogPortHandle Handle to the analog port to use.\n:param in:  bits Number of bits to oversample.\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAnalogOversampleBits"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "samplesPerSecond", "type": "float"}], "tooltip": "Sets the sample rate.\n\nThis is a global setting for the Athena and effects all channels.\n\n:param in:  samplesPerSecond The number of samples per channel per second.\n:param out: status          the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAnalogSampleRate"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "analogTriggerHandle", "type": "int"}, {"name": "useAveragedValue", "type": "int"}], "tooltip": "Configures the analog trigger to use the averaged vs. raw values.\n\nIf the value is true, then the averaged value is selected for the analog\ntrigger, otherwise the immediate value is used.\n\nThis is not allowed to be used if filtered mode is set.\nThis is not allowed to be used with Duty Cycle based inputs.\n\n:param in:  analogTriggerHandle the trigger handle\n:param in:  useAveragedValue    true to use averaged values, false for raw\n:param out: status              Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAnalogTriggerAveraged"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "analogTriggerHandle", "type": "int"}, {"name": "useFilteredValue", "type": "int"}], "tooltip": "Configures the analog trigger to use a filtered value.\n\nThe analog trigger will operate with a 3 point average rejection filter. This\nis designed to help with 360 degree pot applications for the period where the\npot crosses through zero.\n\nThis is not allowed to be used if averaged mode is set.\n\n:param in:  analogTriggerHandle the trigger handle\n:param in:  useFilteredValue    true to use filtered values, false for average\n            or raw\n:param out: status             Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAnalogTriggerFiltered"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "analogTriggerHandle", "type": "int"}, {"name": "lower", "type": "float"}, {"name": "upper", "type": "float"}], "tooltip": "Sets the upper and lower limits of the analog trigger.\n\nThe limits are given as floating point duty cycle values.\n\n:param in:  analogTriggerHandle the trigger handle\n:param in:  lower               the lower duty cycle value\n:param in:  upper               the upper duty cycle value\n:param out: status              Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAnalogTriggerLimitsDutyCycle"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "analogTriggerHandle", "type": "int"}, {"name": "lower", "type": "int"}, {"name": "upper", "type": "int"}], "tooltip": "Sets the raw ADC upper and lower limits of the analog trigger.\n\nHAL_SetAnalogTriggerLimitsVoltage or HAL_SetAnalogTriggerLimitsDutyCycle\nis likely better in most cases.\n\n:param in:  analogTriggerHandle the trigger handle\n:param in:  lower               the lower ADC value\n:param in:  upper               the upper ADC value\n:param out: status              Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAnalogTriggerLimitsRaw"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "analogTriggerHandle", "type": "int"}, {"name": "lower", "type": "float"}, {"name": "upper", "type": "float"}], "tooltip": "Sets the upper and lower limits of the analog trigger.\n\nThe limits are given as floating point voltage values.\n\n:param in:  analogTriggerHandle the trigger handle\n:param in:  lower               the lower voltage value\n:param in:  upper               the upper voltage value\n:param out: status              Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setAnalogTriggerLimitsVoltage"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "voltage", "type": "float"}], "tooltip": "Set the voltage the roboRIO will brownout and disable all outputs.\n\nNote that this only does anything on the roboRIO 2.\nOn the roboRIO it is a no-op.\n\n:param in:  voltage The brownout voltage\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setBrownoutVoltage"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "enabled", "type": "int"}], "tooltip": "Enables the compressor closed loop control using the digital pressure switch.\nThe compressor will turn on when the pressure switch indicates that the\nsystem is not full, and will turn off when the pressure switch indicates that\nthe system is full.\n\n:param in:  handle  the PCM handle\n:param in:  enabled true to enable closed loop control\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setCTREPCMClosedLoopControl"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "index", "type": "int"}, {"name": "durMs", "type": "int"}], "tooltip": "Set the duration for a single solenoid shot.\n\n:param in:  handle  the PCM handle\n:param in:  index solenoid index\n:param in:  durMs shot duration in ms\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setCTREPCMOneShotDuration"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "mask", "type": "int"}, {"name": "values", "type": "int"}], "tooltip": "Sets solenoids on a pneumatics module.\n\n:param in:  handle  the PCM handle\n:param in:  mask Bitmask indicating which solenoids to set. The LSB represents\n            solenoid 0.\n:param in:  values Bitmask indicating the desired states of the solenoids. The\n            LSB represents solenoid 0.\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setCTREPCMSolenoids"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "counterHandle", "type": "int"}, {"name": "size", "type": "int"}], "tooltip": "Sets the average sample size of a counter.\n\n:param in:  counterHandle  the counter handle\n:param in:  size           the size of samples to average\n:param out: status        Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setCounterAverageSize"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "counterHandle", "type": "int"}, {"name": "digitalSourceHandle", "type": "int"}, {"name": "analogTriggerType", "type": "hal._wpiHal.AnalogTriggerType"}], "tooltip": "Sets the source object that causes the counter to count down.\n\n:param in:  counterHandle       the counter handle\n:param in:  digitalSourceHandle the digital source handle (either a\n            HAL_AnalogTriggerHandle or a\n            HAL_DigitalHandle)\n:param in:  analogTriggerType   the analog trigger type if the source is an\n            analog trigger\n:param out: status             Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setCounterDownSource"}, "inputs": {"ARG2": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogTriggerType"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "counterHandle", "type": "int"}, {"name": "risingEdge", "type": "int"}, {"name": "fallingEdge", "type": "int"}], "tooltip": "Sets the down source to either detect rising edges or falling edges.\nNote that both are allowed to be set true at the same time without issues.\n\n:param in:  counterHandle  the counter handle\n:param in:  risingEdge     true to trigger on rising\n:param in:  fallingEdge    true to trigger on falling\n:param out: status        Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setCounterDownSourceEdge"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "counterHandle", "type": "int"}], "tooltip": "Sets directional counting mode on this counter.\n\nThe direction is determined by the B input, with counting happening with the\nA input.\n\n:param in:  counterHandle the counter handle\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setCounterExternalDirectionMode"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "counterHandle", "type": "int"}, {"name": "maxPeriod", "type": "float"}], "tooltip": "Sets the maximum period where the device is still considered \"moving\".\n\nSets the maximum period where the device is considered moving. This value is\nused to determine the \"stopped\" state of the counter using the\nHAL_GetCounterStopped method.\n\n:param in:  counterHandle the counter handle\n:param in:  maxPeriod     the maximum period where the counted device is\n            considered moving in seconds\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setCounterMaxPeriod"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "counterHandle", "type": "int"}, {"name": "threshold", "type": "float"}], "tooltip": "Configures the counter to count in up or down based on the length of the\ninput pulse.\n\nThis mode is most useful for direction sensitive gear tooth sensors.\n\n:param in:  counterHandle the counter handle\n:param in:  threshold     The pulse length beyond which the counter counts the\n            opposite direction (seconds)\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setCounterPulseLengthMode"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "counterHandle", "type": "int"}, {"name": "reverseDirection", "type": "int"}], "tooltip": "Sets the Counter to return reversed sensing on the direction.\n\nThis allows counters to change the direction they are counting in the case of\n1X and 2X quadrature encoding only. Any other counter mode isn't supported.\n\n:param in:  counterHandle    the counter handle\n:param in:  reverseDirection true if the value counted should be negated.\n:param out: status          Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setCounterReverseDirection"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "counterHandle", "type": "int"}, {"name": "samplesToAverage", "type": "int"}], "tooltip": "Sets the Samples to Average which specifies the number of samples of the\ntimer to average when calculating the period. Perform averaging to account\nfor mechanical imperfections or as oversampling to increase resolution.\n\n:param in:  counterHandle    the counter handle\n:param in:  samplesToAverage The number of samples to average from 1 to 127\n:param out: status          Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setCounterSamplesToAverage"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "counterHandle", "type": "int"}, {"name": "highSemiPeriod", "type": "int"}], "tooltip": "Sets Semi-period mode on this counter.\n\nThe counter counts up based on the time the input is triggered. High or Low\ndepends on the highSemiPeriod parameter.\n\n:param in:  counterHandle  the counter handle\n:param in:  highSemiPeriod true for counting when the input is high, false for\n            low\n:param out: status        Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setCounterSemiPeriodMode"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "counterHandle", "type": "int"}], "tooltip": "Sets standard up / down counting mode on this counter.\n\nUp and down counts are sourced independently from two inputs.\n\n:param in:  counterHandle the counter handle\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setCounterUpDownMode"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "counterHandle", "type": "int"}, {"name": "digitalSourceHandle", "type": "int"}, {"name": "analogTriggerType", "type": "hal._wpiHal.AnalogTriggerType"}], "tooltip": "Sets the source object that causes the counter to count up.\n\n:param in:  counterHandle       the counter handle\n:param in:  digitalSourceHandle the digital source handle (either a\n            HAL_AnalogTriggerHandle or a\n            HAL_DigitalHandle)\n:param in:  analogTriggerType   the analog trigger type if the source is an\n            analog trigger\n:param out: status             Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setCounterUpSource"}, "inputs": {"ARG2": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogTriggerType"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "counterHandle", "type": "int"}, {"name": "risingEdge", "type": "int"}, {"name": "fallingEdge", "type": "int"}], "tooltip": "Sets the up source to either detect rising edges or falling edges.\n\nNote that both are allowed to be set true at the same time without issues.\n\n:param in:  counterHandle  the counter handle\n:param in:  risingEdge     true to trigger on rising\n:param in:  fallingEdge    true to trigger on falling\n:param out: status        Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setCounterUpSourceEdge"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "counterHandle", "type": "int"}, {"name": "enabled", "type": "int"}], "tooltip": "Selects whether you want to continue updating the event timer output when\nthere are no samples captured.\n\nThe output of the event timer has a buffer of periods that are averaged and\nposted to a register on the FPGA.  When the timer detects that the event\nsource has stopped (based on the MaxPeriod) the buffer of samples to be\naveraged is emptied.\n\nIf you enable the update when empty, you will be\nnotified of the stopped source and the event time will report 0 samples.\n\nIf you disable update when empty, the most recent average will remain on the\noutput until a new sample is acquired.\n\nYou will never see 0 samples output (except when there have been no events\nsince an FPGA reset) and you will likely not see the stopped bit become true\n(since it is updated at the end of an average and there are no samples to\naverage).\n\n:param in:  counterHandle the counter handle\n:param in:  enabled       true to enable counter updating with no samples\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setCounterUpdateWhenEmpty"}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "realTime", "type": "int"}, {"name": "priority", "type": "int"}], "tooltip": "Sets the thread priority for the current thread.\n\n:param in:  realTime Set to true to set a real-time priority, false for\n            standard priority.\n:param in:  priority Priority to set the thread to. For real-time, this is\n            1-99 with 99 being highest. For non-real-time, this is\n            forced to 0. See \"man 7 sched\" for more details.\n:param out: status  Error status variable. 0 on success.\n\n:returns: True on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setCurrentThreadPriority"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "dioPortHandle", "type": "int"}, {"name": "value", "type": "int"}], "tooltip": "Writes a digital value to a DIO channel.\n\n:param in:  dioPortHandle the digital port handle\n:param in:  value         the state to set the digital channel (if it is\n            configured as an output)\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setDIO"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "dioPortHandle", "type": "int"}, {"name": "input", "type": "int"}], "tooltip": "Sets the direction of a DIO channel.\n\n:param in:  dioPortHandle the digital port handle\n:param in:  input         true to set input, false for output\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setDIODirection"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "handle", "type": "int"}, {"name": "device", "type": "int"}], "tooltip": "Indicates the DIO channel is used by a simulated device.\n\n:param handle: the DIO channel handle\n:param device: simulated device handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setDIOSimDevice"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "pwmGenerator", "type": "int"}, {"name": "dutyCycle", "type": "float"}], "tooltip": "Configures the duty-cycle of the PWM generator.\n\n:param in:  pwmGenerator the digital PWM handle\n:param in:  dutyCycle    the percent duty cycle to output [0..1]\n:param out: status      Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setDigitalPWMDutyCycle"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "pwmGenerator", "type": "int"}, {"name": "channel", "type": "int"}], "tooltip": "Configures which DO channel the PWM signal is output on.\n\n:param in:  pwmGenerator the digital PWM handle\n:param in:  channel      the channel to output on\n:param out: status      Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setDigitalPWMOutputChannel"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "pwmGenerator", "type": "int"}, {"name": "dutyCycle", "type": "float"}], "tooltip": "Configures the digital PWM to be a PPS signal with specified duty cycle.\n\n:param in:  pwmGenerator the digital PWM handle\n:param in:  dutyCycle    the percent duty cycle to output [0..1]\n:param out: status      Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setDigitalPWMPPS"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "rate", "type": "float"}], "tooltip": "Changes the frequency of the DO PWM generator.\n\nThe valid range is from 0.6 Hz to 19 kHz.\n\nThe frequency resolution is logarithmic.\n\n:param in:  rate the frequency to output all digital output PWM signals\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setDigitalPWMRate"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "handle", "type": "int"}, {"name": "device", "type": "int"}], "tooltip": "Indicates the duty cycle is used by a simulated device.\n\n:param handle: the duty cycle handle\n:param device: simulated device handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setDutyCycleSimDevice"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "encoderHandle", "type": "int"}, {"name": "distancePerPulse", "type": "float"}], "tooltip": "Sets the distance traveled per encoder pulse. This is used as a scaling\nfactor for the rate and distance calls.\n\n:param in:  encoderHandle    the encoder handle\n:param in:  distancePerPulse the distance traveled per encoder pulse (units\n            user defined)\n:param out: status          Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setEncoderDistancePerPulse"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "encoderHandle", "type": "int"}, {"name": "digitalSourceHandle", "type": "int"}, {"name": "analogTriggerType", "type": "hal._wpiHal.AnalogTriggerType"}, {"name": "type", "type": "hal._wpiHal.EncoderIndexingType"}], "tooltip": "Sets the source for an index pulse on the encoder.\n\nThe index pulse can be used to cause an encoder to reset based on an external\ninput.\n\n:param in:  encoderHandle       the encoder handle\n:param in:  digitalSourceHandle the index source handle (either a\n            HAL_AnalogTriggerHandle or a\n            HAL_DigitalHandle)\n:param in:  analogTriggerType   the analog trigger type if the source is an\n            analog trigger\n:param in:  type                the index triggering type\n:param out: status             Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setEncoderIndexSource"}, "inputs": {"ARG2": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogTriggerType"}}}}, "ARG3": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myEncoderIndexingType"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "encoderHandle", "type": "int"}, {"name": "maxPeriod", "type": "float"}], "tooltip": "Sets the maximum period where the device is still considered \"moving\".\n\nSets the maximum period where the device is considered moving. This value is\nused to determine the \"stopped\" state of the encoder using the\nHAL_GetEncoderStopped method.\n\n:param in:  encoderHandle the encoder handle\n:param in:  maxPeriod     the maximum period where the counted device is\n            considered moving in seconds\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setEncoderMaxPeriod"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "encoderHandle", "type": "int"}, {"name": "minRate", "type": "float"}], "tooltip": "Sets the minimum rate to be considered moving by the encoder.\n\nUnits need to match what is set by HAL_SetEncoderDistancePerPulse, with time\nas seconds.\n\n:param in:  encoderHandle the encoder handle\n:param in:  minRate       the minimum rate to be considered moving (units are\n            determined by the units passed to\n            HAL_SetEncoderDistancePerPulse, time value is\n            seconds)\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setEncoderMinRate"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "encoderHandle", "type": "int"}, {"name": "reverseDirection", "type": "int"}], "tooltip": "Sets if to reverse the direction of the encoder.\n\nNote that this is not a toggle. It is an absolute set.\n\n:param in:  encoderHandle    the encoder handle\n:param in:  reverseDirection true to reverse the direction, false to not.\n:param out: status          Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setEncoderReverseDirection"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "encoderHandle", "type": "int"}, {"name": "samplesToAverage", "type": "int"}], "tooltip": "Sets the number of encoder samples to average when calculating encoder rate.\n\n:param in:  encoderHandle    the encoder handle\n:param in:  samplesToAverage the number of samples to average\n:param out: status          Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setEncoderSamplesToAverage"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "handle", "type": "int"}, {"name": "device", "type": "int"}], "tooltip": "Indicates the encoder is used by a simulated device.\n\n:param handle: the encoder handle\n:param device: simulated device handle", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setEncoderSimDevice"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "filterIndex", "type": "int"}, {"name": "value", "type": "int"}], "tooltip": "Sets the filter period for the specified filter index.\n\nSets the filter period in FPGA cycles.  Even though there are 2 different\nfilter index domains (MXP vs HDR), ignore that distinction for now since it\ncomplicates the interface.  That can be changed later.\n\n:param in:  filterIndex the filter index, 0 - 2\n:param in:  value       the number of cycles that the signal must not\n            transition to be counted as a transition.\n:param out: status     Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setFilterPeriod"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "dioPortHandle", "type": "int"}, {"name": "filterIndex", "type": "int"}], "tooltip": "Writes the filter index from the FPGA.\n\nSet the filter index used to filter out short pulses.\n\n:param in:  dioPortHandle the digital port handle\n:param in:  filterIndex   the filter index (Must be in the range 0 - 3, where\n            0 means \"none\" and 1 - 3 means filter # filterIndex\n            - 1)\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setFilterSelect"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "interruptHandle", "type": "int"}, {"name": "risingEdge", "type": "int"}, {"name": "fallingEdge", "type": "int"}], "tooltip": "Sets the edges to trigger the interrupt on.\n\nNote that both edges triggered is a valid configuration.\n\n:param in:  interruptHandle the interrupt handle\n:param in:  risingEdge      true for triggering on rising edge\n:param in:  fallingEdge     true for triggering on falling edge\n:param out: status         Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setInterruptUpSourceEdge"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "joystickNum", "type": "int"}, {"name": "outputs", "type": "int"}, {"name": "leftRumble", "type": "int"}, {"name": "rightRumble", "type": "int"}], "tooltip": "Set joystick outputs.\n\n:param joystickNum: the joystick number\n:param outputs:     bitmask of outputs, 1 for on 0 for off\n:param leftRumble:  the left rumble value (0-FFFF)\n:param rightRumble: the right rumble value (0-FFFF)\n\n:returns: the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setJoystickOutputs"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "notifierHandle", "type": "int"}, {"name": "name", "type": "str"}], "tooltip": "Sets the name of a notifier.\n\n:param in:  notifierHandle the notifier handle\n:param in:  name name\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setNotifierName"}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "realTime", "type": "int"}, {"name": "priority", "type": "int"}], "tooltip": "Sets the HAL notifier thread priority.\n\nThe HAL notifier thread is responsible for managing the FPGA's notifier\ninterrupt and waking up user's Notifiers when it's their time to run.\nGiving the HAL notifier thread real-time priority helps ensure the user's\nreal-time Notifiers, if any, are notified to run in a timely manner.\n\n:param in:  realTime Set to true to set a real-time priority, false for\n            standard priority.\n:param in:  priority Priority to set the thread to. For real-time, this is\n            1-99 with 99 being highest. For non-real-time, this is\n            forced to 0. See \"man 7 sched\" for more details.\n:param out: status  Error status variable. 0 on success.\n\n:returns: True on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setNotifierThreadPriority"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "pwmPortHandle", "type": "int"}], "tooltip": "Sets the PWM output to be a continuous high signal while enabled.\n\n:param in:  pwmPortHandle the PWM handle.\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setPWMAlwaysHighMode"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "pwmPortHandle", "type": "int"}, {"name": "maxPwm", "type": "int"}, {"name": "deadbandMaxPwm", "type": "int"}, {"name": "centerPwm", "type": "int"}, {"name": "deadbandMinPwm", "type": "int"}, {"name": "minPwm", "type": "int"}], "tooltip": "Sets the configuration settings for the PWM channel.\n\nAll values are in microseconds.\n\n:param in:  pwmPortHandle  the PWM handle\n:param in:  maxPwm         the maximum PWM value\n:param in:  deadbandMaxPwm the high range of the center deadband\n:param in:  centerPwm      the center PWM value\n:param in:  deadbandMinPwm the low range of the center deadband\n:param in:  minPwm         the minimum PWM value\n:param out: status        Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setPWMConfigMicroseconds"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "pwmPortHandle", "type": "int"}], "tooltip": "Sets a PWM channel to be disabled.\n\nThe channel is disabled until the next time it is set. Note this is different\nfrom just setting a 0 speed, as this will actively stop all signaling on the\nchannel.\n\n:param in:  pwmPortHandle the PWM handle.\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setPWMDisabled"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "pwmPortHandle", "type": "int"}, {"name": "eliminateDeadband", "type": "int"}], "tooltip": "Sets if the FPGA should output the center value if the input value is within\nthe deadband.\n\n:param in:  pwmPortHandle     the PWM handle\n:param in:  eliminateDeadband true to eliminate deadband, otherwise false\n:param out: status           Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setPWMEliminateDeadband"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "pwmPortHandle", "type": "int"}, {"name": "squelchMask", "type": "int"}], "tooltip": "Sets how how often the PWM signal is squelched, thus scaling the period.\n\n:param in:  pwmPortHandle the PWM handle.\n:param in:  squelchMask   the 2-bit mask of outputs to squelch\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setPWMPeriodScale"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "pwmPortHandle", "type": "int"}, {"name": "position", "type": "float"}], "tooltip": "Sets a PWM channel to the desired position value.\n\nThe values range from 0 to 1 and the period is controlled by the PWM Period\nand MinHigh registers.\n\n:param in:  pwmPortHandle the PWM handle\n:param in:  position      the positional PWM value to set\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setPWMPosition"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "pwmPortHandle", "type": "int"}, {"name": "microsecondPulseTime", "type": "int"}], "tooltip": "Sets a PWM channel to the desired pulse width in microseconds.\n\n:param in:  pwmPortHandle the PWM handle\n:param in:  microsecondPulseTime  the PWM value to set\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setPWMPulseTimeMicroseconds"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "pwmPortHandle", "type": "int"}, {"name": "speed", "type": "float"}], "tooltip": "Sets a PWM channel to the desired scaled value.\n\nThe values range from -1 to 1 and the period is controlled by the PWM Period\nand MinHigh registers.\n\n:param in:  pwmPortHandle the PWM handle\n:param in:  speed         the scaled PWM value to set\n:param out: status       Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setPWMSpeed"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "enabled", "type": "int"}], "tooltip": "Power on/off switchable channel.\n\nThis is a REV PDH-specific function. This function will no-op on CTRE PDP.\n\n:param in:  handle the module handle\n:param in:  enabled true to turn on switchable channel\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setPowerDistributionSwitchableChannel"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "minAnalogVoltage", "type": "float"}, {"name": "maxAnalogVoltage", "type": "float"}], "tooltip": "Enables the compressor in analog mode. This mode uses an analog\npressure sensor connected to analog channel 0 to cycle the compressor. The\ncompressor will turn on when the pressure drops below minAnalogVoltage and\nwill turn off when the pressure reaches maxAnalogVoltage. This mode is only\nsupported by the REV PH with the REV Analog Pressure Sensor connected to\nanalog channel 0.\n\n:param in:  handle  the PH handle\n:param in:  minAnalogVoltage The compressor will turn on when the analog\n            pressure sensor voltage drops below this value\n:param in:  maxAnalogVoltage The compressor will turn off when the analog\n            pressure sensor reaches this value.\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setREVPHClosedLoopControlAnalog"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}], "tooltip": "Enables the compressor in digital mode using the digital pressure switch. The\ncompressor will turn on when the pressure switch indicates that the system is\nnot full, and will turn off when the pressure switch indicates that the\nsystem is full.\n\n:param in:  handle  the PH handle\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setREVPHClosedLoopControlDigital"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}], "tooltip": "Disable Compressor.\n\n:param in:  handle  the PH handle\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setREVPHClosedLoopControlDisabled"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "minAnalogVoltage", "type": "float"}, {"name": "maxAnalogVoltage", "type": "float"}], "tooltip": "Enables the compressor in hybrid mode. This mode uses both a digital\npressure switch and an analog pressure sensor connected to analog channel 0\nto cycle the compressor.\n\nThe compressor will turn on when \\a both:\n\n- The digital pressure switch indicates the system is not full AND\n- The analog pressure sensor indicates that the pressure in the system is\nbelow the specified minimum pressure.\n\nThe compressor will turn off when \\a either:\n\n- The digital pressure switch is disconnected or indicates that the system\nis full OR\n- The pressure detected by the analog sensor is greater than the specified\nmaximum pressure.\n\n:param in:  handle  the PH handle\n:param in:  minAnalogVoltage The compressor will turn on when the analog\n            pressure sensor voltage drops below this value and the pressure switch\n            indicates that the system is not full.\n:param in:  maxAnalogVoltage The compressor will turn off when the analog\n            pressure sensor reaches this value or the pressure switch is disconnected or\n            indicates that the system is full.\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setREVPHClosedLoopControlHybrid"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "config", "type": "hal._wpiHal.REVPHCompressorConfig"}], "tooltip": "Send compressor configuration to the PH.\n\n:param in:  handle  the PH handle\n:param in:  config  compressor configuration\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setREVPHCompressorConfig"}, "inputs": {"ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myREVPHCompressorConfig"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "mask", "type": "int"}, {"name": "values", "type": "int"}], "tooltip": "Sets solenoids on a PH.\n\n:param in:  handle  the PH handle\n:param in:  mask Bitmask indicating which solenoids to set. The LSB represents\n            solenoid 0.\n:param in:  values Bitmask indicating the desired states of the solenoids. The\n            LSB represents solenoid 0.\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setREVPHSolenoids"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "relayPortHandle", "type": "int"}, {"name": "on", "type": "int"}], "tooltip": "Sets the state of a relay output.\n\n:param in:  relayPortHandle the relay handle\n:param in:  on              true for on, false for off\n:param out: status         Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setRelay"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}, {"name": "dataToSend", "type": "Buffer"}, {"name": "zeroSize", "type": "int"}], "tooltip": "Sets the data to be transmitted to the device to initiate a read.\n\n:param in:  port       The number of the port to use. 0-3 for Onboard CS0-CS2,\n            4 for MXP.\n:param in:  dataToSend Pointer to the data to send (Gets copied for continue\n            use, so no need to keep alive).\n:param in:  dataSize   The length of the data to send.\n:param in:  zeroSize   The number of zeros to send after the data.\n:param out: status    the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setSPIAutoTransmitData"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}], "tooltip": "Sets the CS Active high for a SPI port.\n\n:param in:  port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n            MXP\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setSPIChipSelectActiveHigh"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}], "tooltip": "Sets the CS Active low for a SPI port.\n\n:param in:  port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n            for MXP\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setSPIChipSelectActiveLow"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}, {"name": "handle", "type": "int"}], "tooltip": "Sets the stored handle for a SPI port.\n\n:param port:   The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n               MXP.\n:param handle: The value of the handle for the port.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setSPIHandle"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}, {"name": "mode", "type": "hal._wpiHal.SPIMode"}], "tooltip": "Sets the SPI Mode.\n\n:param port: The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n             MXP\n:param mode: The SPI mode to use", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setSPIMode"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIMode"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}, {"name": "speed", "type": "int"}], "tooltip": "Sets the clock speed for the SPI bus.\n\n:param port:  The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n              MXP\n:param speed: The speed in Hz (500KHz-10MHz)", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setSPISpeed"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "baud", "type": "int"}], "tooltip": "Sets the baud rate of a serial port.\n\nAny value between 0 and 0xFFFFFFFF may be used. Default is 9600.\n\n:param in:  handle  the serial port handle\n:param in:  baud    the baud rate to set\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setSerialBaudRate"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "bits", "type": "int"}], "tooltip": "Sets the number of data bits on a serial port.\n\nDefaults to 8.\n\n:param in:  handle  the serial port handle\n:param in:  bits    the number of data bits (5-8)\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setSerialDataBits"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "flow", "type": "int"}], "tooltip": "Sets the flow control mode of a serial port.\n\nValid values are:\n0: None (default)\n1: XON-XOFF\n2: RTS-CTS\n3: DTR-DSR\n\n:param in:  handle  the serial port handle\n:param in:  flow    the mode to set (see remarks for valid values)\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setSerialFlowControl"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "parity", "type": "int"}], "tooltip": "Sets the number of parity bits on a serial port.\n\nValid values are:\n0: None (default)\n1: Odd\n2: Even\n3: Mark - Means exists and always 1\n4: Space - Means exists and always 0\n\n:param in:  handle  the serial port handle\n:param in:  parity  the parity bit mode (see remarks for valid values)\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setSerialParity"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "size", "type": "int"}], "tooltip": "Sets the size of the read buffer.\n\n:param in:  handle  the serial port handle\n:param in:  size    the read buffer size\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setSerialReadBufferSize"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "stopBits", "type": "int"}], "tooltip": "Sets the number of stop bits on a serial port.\n\nValid values are:\n10: One stop bit (default)\n15: One and a half stop bits\n20: Two stop bits\n\n:param in:  handle    the serial port handle\n:param in:  stopBits  the stop bit value (see remarks for valid values)\n:param out: status   the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setSerialStopBits"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "timeout", "type": "float"}], "tooltip": "Sets the minimum serial read timeout of a port.\n\n:param in:  handle   the serial port handle\n:param in:  timeout  the timeout in milliseconds\n:param out: status  the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setSerialTimeout"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "size", "type": "int"}], "tooltip": "Sets the size of the write buffer.\n\n:param in:  handle  the serial port handle\n:param in:  size    the write buffer size\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setSerialWriteBufferSize"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "mode", "type": "int"}], "tooltip": "Sets the write mode on a serial port.\n\nValid values are:\n1: Flush on access\n2: Flush when full (default)\n\n:param in:  handle  the serial port handle\n:param in:  mode    the mode to set (see remarks for valid values)\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setSerialWriteMode"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [{"name": "showMessage", "type": "int"}], "tooltip": "Enables or disables the message saying no HAL extensions were found.\n\nSome apps don't care, and the message create clutter. For general team code,\nwe want it.\n\nThis must be called before HAL_Initialize is called.\n\nThis defaults to true.\n\n:param showMessage: true to show message, false to not.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setShowExtensionsNotFoundMessages"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "enabled", "type": "int"}], "tooltip": "Enables or disables the 3V3 rail.\n\n:param enabled: whether the rail should be enabled\n:param out:     status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setUserRailEnabled3V3"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "enabled", "type": "int"}], "tooltip": "Enables or disables the 5V rail.\n\n:param enabled: whether the rail should be enabled\n:param out:     status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setUserRailEnabled5V"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "enabled", "type": "int"}], "tooltip": "Enables or disables the 6V rail.\n\n:param enabled: whether the rail should be enabled\n:param out:     status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setUserRailEnabled6V"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}], "tooltip": "Sets up an analog gyro with the proper offsets and settings for the KOP\nanalog gyro.\n\n:param in:  handle the gyro handle\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "setupAnalogGyro"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [], "tooltip": "Call this to shut down HAL.\n\nThis must be called at termination of the robot program to avoid potential\nsegmentation faults with simulation extensions at exit.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "shutdown"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [], "tooltip": "Calls registered SimPeriodic \"after\" callbacks (only in simulation mode).\nThis should be called after user code periodic simulation functions.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "simPeriodicAfter"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "None", "args": [], "tooltip": "Calls registered SimPeriodic \"before\" callbacks (only in simulation mode).\nThis should be called prior to user code periodic simulation functions.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "simPeriodicBefore"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}], "tooltip": "Starts the output.\n\nThe output writes continuously.\n\n:param in:  handle the Addressable LED handle\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "startAddressableLEDOutput"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}, {"name": "period", "type": "float"}], "tooltip": "Sets the period for automatic SPI accumulation.\n\n:param in:  port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n            for MXP.\n:param in:  period  The accumulation period (seconds).\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "startSPIAutoRate"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}, {"name": "digitalSourceHandle", "type": "int"}, {"name": "analogTriggerType", "type": "hal._wpiHal.AnalogTriggerType"}, {"name": "triggerRising", "type": "int"}, {"name": "triggerFalling", "type": "int"}], "tooltip": "Starts the auto SPI accumulator on a specific trigger.\n\nNote that triggering on both rising and falling edges is a valid\nconfiguration.\n\n:param in:  port                The number of the port to use. 0-3 for Onboard\n            CS0-CS2, 4 for MXP.\n:param in:  digitalSourceHandle The trigger source to use (Either\n            HAL_AnalogTriggerHandle or HAL_DigitalHandle).\n:param in:  analogTriggerType   The analog trigger type, if the source is an\n            analog trigger.\n:param in:  triggerRising       Trigger on the rising edge if true.\n:param in:  triggerFalling      Trigger on the falling edge if true.\n:param out: status             the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "startSPIAutoTrigger"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}, "ARG2": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAnalogTriggerType"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}], "tooltip": "Stops the output.\n\n:param in:  handle the Addressable LED handle\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "stopAddressableLEDOutput"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "apiId", "type": "int"}], "tooltip": "Stops a repeating packet with a specific ID.\n\nThis ID is 10 bits.\n\n:param in:  handle  the CAN handle\n:param in:  apiId   the ID to stop repeating (0-1023)\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "stopCANPacketRepeating"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "notifierHandle", "type": "int"}], "tooltip": "Stops a notifier from running.\n\nThis will cause any call into HAL_WaitForNotifierAlarm to return with time =\n0.\n\n:param in:  notifierHandle the notifier handle\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "stopNotifier"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}], "tooltip": "Stops an automatic SPI accumulation.\n\n:param in:  port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n            for MXP.\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "stopSPIAuto"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "port", "type": "hal._wpiHal.I2CPort"}, {"name": "deviceAddress", "type": "int"}, {"name": "dataToSend", "type": "Buffer"}, {"name": "dataReceived", "type": "Buffer"}], "tooltip": "Generic I2C read/write transaction.\n\nThis is a lower-level interface to the I2C hardware giving you more control\nover each transaction.\n\n:param port:          The I2C port, 0 for the on-board, 1 for the MXP.\n:param deviceAddress: The address of the register on the device to be\n                      read/written.\n:param dataToSend:    Buffer of data to send as part of the transaction.\n:param sendSize:      Number of bytes to send as part of the transaction.\n:param dataReceived:  Buffer to read data into.\n:param receiveSize:   Number of bytes to read from the device.\n\n:returns: 0 on success or -1 on transfer abort.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "transactionI2C"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myI2CPort"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}, {"name": "dataToSend", "type": "Buffer"}, {"name": "dataReceived", "type": "Buffer"}], "tooltip": "Performs an SPI send/receive transaction.\n\nThis is a lower-level interface to the spi hardware giving you more control\nover each transaction.\n\n:param port:         The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                     for MXP\n:param dataToSend:   Buffer of data to send as part of the transaction.\n:param dataReceived: Buffer to read data into.\n:param size:         Number of bytes to transfer. [0..7]\n\n:returns: Number of bytes transferred, -1 for error", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "transactionSPI"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "notifierHandle", "type": "int"}, {"name": "triggerTime", "type": "int"}], "tooltip": "Updates the trigger time for a notifier.\n\nNote that this time is an absolute time relative to HAL_GetFPGATime()\n\n:param in:  notifierHandle the notifier handle\n:param in:  triggerTime    the updated trigger time\n:param out: status        Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "updateNotifierAlarm"}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "interruptHandle", "type": "int"}, {"name": "timeout", "type": "float"}, {"name": "ignorePrevious", "type": "int"}], "tooltip": "Waits for the defined interrupt to occur.\n\n:param in:  interruptHandle the interrupt handle\n:param in:  timeout         timeout in seconds\n:param in:  ignorePrevious  if true, ignore interrupts that happened before\n            waitForInterrupt was called\n:param out: status         Error status variable. 0 on success.\n\n:returns: the mask of interrupts that fired", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "waitForInterrupt"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "interruptHandle", "type": "int"}, {"name": "mask", "type": "int"}, {"name": "timeout", "type": "float"}, {"name": "ignorePrevious", "type": "int"}], "tooltip": "Waits for any interrupt covered by the mask to occur.\n\n:param in:  interruptHandle the interrupt handle to use for the context\n:param in:  mask            the mask of interrupts to wait for\n:param in:  timeout         timeout in seconds\n:param in:  ignorePrevious  if true, ignore interrupts that happened before\n            waitForInterrupt was called\n:param out: status         Error status variable. 0 on success.\n\n:returns: the mask of interrupts that fired", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "waitForMultipleInterrupts"}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "notifierHandle", "type": "int"}], "tooltip": "Waits for the next alarm for the specific notifier.\n\nThis is a blocking call until either the time elapses or HAL_StopNotifier\ngets called. If the latter occurs, this function will return zero and any\nloops using this function should exit. Failing to do so can lead to\nuse-after-frees.\n\n:param in:  notifierHandle the notifier handle\n:param out: status        Error status variable. 0 on success.\n\n:returns: the FPGA time the notifier returned", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "waitForNotifierAlarm"}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "data", "type": "hal._wpiHal.AddressableLEDData"}, {"name": "length", "type": "int"}], "tooltip": "Sets the led output data.\n\nIf the output is enabled, this will start writing the next data cycle.\nIt is safe to call, even while output is enabled.\n\n:param in:  handle the Addressable LED handle\n:param in:  data the buffer to write\n:param in:  length the strip length\n:param out: status the error code, or 0 for success", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "writeAddressableLEDData"}, "inputs": {"ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myAddressableLEDData"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "data", "type": "Buffer"}, {"name": "apiId", "type": "int"}], "tooltip": "Writes a packet to the CAN device with a specific ID.\n\nThis ID is 10 bits.\n\n:param in:  handle  the CAN handle\n:param in:  data    the data to write (0-8 bytes)\n:param in:  length  the length of data (0-8)\n:param in:  apiId   the ID to write (0-1023 bits)\n:param out: status Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "writeCANPacket"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "data", "type": "Buffer"}, {"name": "apiId", "type": "int"}, {"name": "repeatMs", "type": "int"}], "tooltip": "Writes a repeating packet to the CAN device with a specific ID.\n\nThis ID is 10 bits.\n\nThe RoboRIO will automatically repeat the packet at the specified interval\n\n:param in:  handle   the CAN handle\n:param in:  data     the data to write (0-8 bytes)\n:param in:  length   the length of data (0-8)\n:param in:  apiId    the ID to write (0-1023)\n:param in:  repeatMs the period to repeat in ms\n:param out: status  Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "writeCANPacketRepeating"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "handle", "type": "int"}, {"name": "length", "type": "int"}, {"name": "apiId", "type": "int"}], "tooltip": "Writes an RTR frame of the specified length to the CAN device with the\nspecific ID.\n\nBy spec, the length must be equal to the length sent by the other device,\notherwise behavior is unspecified.\n\n:param in:  handle   the CAN handle\n:param in:  length   the length of data to request (0-8)\n:param in:  apiId    the ID to write (0-1023)\n:param out: status  Error status variable. 0 on success.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "writeCANRTRFrame"}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "port", "type": "hal._wpiHal.I2CPort"}, {"name": "deviceAddress", "type": "int"}, {"name": "dataToSend", "type": "Buffer"}], "tooltip": "Executes a write transaction with the device.\n\nWrites a single byte to a register on a device and wait until the\ntransaction is complete.\n\n:param port:          The I2C port, 0 for the on-board, 1 for the MXP.\n:param deviceAddress: The address of the register on the device to be\n                      written.\n:param dataToSend:    The byte to write to the register on the device.\n:param sendSize:      Number of bytes to send.\n\n:returns: 0 on success or -1 on transfer abort.", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "writeI2C"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myI2CPort"}}}}}},
      {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "int", "args": [{"name": "port", "type": "hal._wpiHal.SPIPort"}, {"name": "dataToSend", "type": "Buffer"}], "tooltip": "Executes a write transaction with the device.\n\nWrites to a device and wait until the transaction is complete.\n\n:param port:       The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                   for MXP\n:param dataToSend: The data to write to the register on the device.\n:param sendSize:   The number of bytes to be written\n\n:returns: The number of bytes written. -1 for an error", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "writeSPI"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "mySPIPort"}}}}}},
      {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myTuple"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "module", "returnType": "tuple[int, int]", "args": [{"name": "handle", "type": "int"}, {"name": "buffer", "type": "Buffer"}], "tooltip": "Writes data to the serial port.\n\n:param in:  handle  the serial port handle\n:param in:  buffer  the buffer to write\n:param in:  count   the number of bytes to write from the buffer\n:param out: status the error code, or 0 for success\n\n:returns: the number of bytes actually written", "importModule": "hal"}, "fields": {"MODULE_OR_CLASS": "hal", "FUNC": "writeSerial"}}}}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.AccelerometerRange", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.AccelerometerRange", "ENUM_VALUE": "k2G"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.AccelerometerRange", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.AccelerometerRange", "ENUM_VALUE": "k4G"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.AccelerometerRange", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.AccelerometerRange", "ENUM_VALUE": "k8G"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.AllianceStationID", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.AllianceStationID", "ENUM_VALUE": "kBlue1"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.AllianceStationID", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.AllianceStationID", "ENUM_VALUE": "kBlue2"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.AllianceStationID", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.AllianceStationID", "ENUM_VALUE": "kBlue3"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.AllianceStationID", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.AllianceStationID", "ENUM_VALUE": "kRed1"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.AllianceStationID", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.AllianceStationID", "ENUM_VALUE": "kRed2"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.AllianceStationID", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.AllianceStationID", "ENUM_VALUE": "kRed3"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.AllianceStationID", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.AllianceStationID", "ENUM_VALUE": "kUnknown"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.AnalogTriggerType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.AnalogTriggerType", "ENUM_VALUE": "kFallingPulse"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.AnalogTriggerType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.AnalogTriggerType", "ENUM_VALUE": "kInWindow"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.AnalogTriggerType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.AnalogTriggerType", "ENUM_VALUE": "kRisingPulse"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.AnalogTriggerType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.AnalogTriggerType", "ENUM_VALUE": "kState"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANDeviceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANDeviceType", "ENUM_VALUE": "kAccelerometer"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANDeviceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANDeviceType", "ENUM_VALUE": "kBroadcast"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANDeviceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANDeviceType", "ENUM_VALUE": "kFirmwareUpdate"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANDeviceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANDeviceType", "ENUM_VALUE": "kGearToothSensor"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANDeviceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANDeviceType", "ENUM_VALUE": "kGyroSensor"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANDeviceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANDeviceType", "ENUM_VALUE": "kIOBreakout"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANDeviceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANDeviceType", "ENUM_VALUE": "kMiscellaneous"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANDeviceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANDeviceType", "ENUM_VALUE": "kMotorController"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANDeviceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANDeviceType", "ENUM_VALUE": "kPneumatics"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANDeviceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANDeviceType", "ENUM_VALUE": "kPowerDistribution"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANDeviceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANDeviceType", "ENUM_VALUE": "kRelayController"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANDeviceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANDeviceType", "ENUM_VALUE": "kRobotController"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANDeviceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANDeviceType", "ENUM_VALUE": "kServoController"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANDeviceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANDeviceType", "ENUM_VALUE": "kUltrasonicSensor"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANManufacturer", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANManufacturer", "ENUM_VALUE": "kAndyMark"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANManufacturer", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANManufacturer", "ENUM_VALUE": "kBroadcast"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANManufacturer", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANManufacturer", "ENUM_VALUE": "kCTRE"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANManufacturer", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANManufacturer", "ENUM_VALUE": "kCopperforge"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANManufacturer", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANManufacturer", "ENUM_VALUE": "kDEKA"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANManufacturer", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANManufacturer", "ENUM_VALUE": "kGrapple"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANManufacturer", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANManufacturer", "ENUM_VALUE": "kKauaiLabs"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANManufacturer", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANManufacturer", "ENUM_VALUE": "kLM"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANManufacturer", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANManufacturer", "ENUM_VALUE": "kMS"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANManufacturer", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANManufacturer", "ENUM_VALUE": "kNI"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANManufacturer", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANManufacturer", "ENUM_VALUE": "kPWF"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANManufacturer", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANManufacturer", "ENUM_VALUE": "kREV"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANManufacturer", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANManufacturer", "ENUM_VALUE": "kReduxRobotics"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANManufacturer", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANManufacturer", "ENUM_VALUE": "kStudica"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANManufacturer", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANManufacturer", "ENUM_VALUE": "kTeamUse"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANManufacturer", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANManufacturer", "ENUM_VALUE": "kTheThriftyBot"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CANManufacturer", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CANManufacturer", "ENUM_VALUE": "kVividHosting"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CounterMode", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CounterMode", "ENUM_VALUE": "kExternalDirection"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CounterMode", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CounterMode", "ENUM_VALUE": "kPulseLength"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CounterMode", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CounterMode", "ENUM_VALUE": "kSemiperiod"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.CounterMode", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.CounterMode", "ENUM_VALUE": "kTwoPulse"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.EncoderEncodingType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.EncoderEncodingType", "ENUM_VALUE": "Encoder_k1X"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.EncoderEncodingType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.EncoderEncodingType", "ENUM_VALUE": "Encoder_k2X"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.EncoderEncodingType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.EncoderEncodingType", "ENUM_VALUE": "Encoder_k4X"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.EncoderIndexingType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.EncoderIndexingType", "ENUM_VALUE": "kResetOnFallingEdge"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.EncoderIndexingType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.EncoderIndexingType", "ENUM_VALUE": "kResetOnRisingEdge"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.EncoderIndexingType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.EncoderIndexingType", "ENUM_VALUE": "kResetWhileHigh"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.EncoderIndexingType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.EncoderIndexingType", "ENUM_VALUE": "kResetWhileLow"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HAL_RadioLEDState", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HAL_RadioLEDState", "ENUM_VALUE": "HAL_RadioLED_kGreen"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HAL_RadioLEDState", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HAL_RadioLEDState", "ENUM_VALUE": "HAL_RadioLED_kOff"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HAL_RadioLEDState", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HAL_RadioLEDState", "ENUM_VALUE": "HAL_RadioLED_kOrange"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HAL_RadioLEDState", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HAL_RadioLEDState", "ENUM_VALUE": "HAL_RadioLED_kRed"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "AddressableLED"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "AnalogGyro"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "AnalogInput"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "AnalogOutput"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "AnalogTrigger"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "CAN"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "CTREPCM"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "CTREPDP"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "Compressor"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "Counter"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "DIO"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "DMA"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "DigitalPWM"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "DutyCycle"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "Encoder"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "FPGAEncoder"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "Interrupt"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "Notifier"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "PWM"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "Port"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "REVPDH"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "REVPH"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "Relay"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "SerialPort"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "SimulationJni"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "Solenoid"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "Undefined"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.HandleEnum", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.HandleEnum", "ENUM_VALUE": "Vendor"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.I2CPort", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.I2CPort", "ENUM_VALUE": "kInvalid"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.I2CPort", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.I2CPort", "ENUM_VALUE": "kMXP"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.I2CPort", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.I2CPort", "ENUM_VALUE": "kOnboard"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.MatchType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.MatchType", "ENUM_VALUE": "elimination"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.MatchType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.MatchType", "ENUM_VALUE": "none"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.MatchType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.MatchType", "ENUM_VALUE": "practice"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.MatchType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.MatchType", "ENUM_VALUE": "qualification"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.PowerDistributionType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.PowerDistributionType", "ENUM_VALUE": "kAutomatic"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.PowerDistributionType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.PowerDistributionType", "ENUM_VALUE": "kCTRE"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.PowerDistributionType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.PowerDistributionType", "ENUM_VALUE": "kRev"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.REVPHCompressorConfigType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.REVPHCompressorConfigType", "ENUM_VALUE": "kAnalog"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.REVPHCompressorConfigType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.REVPHCompressorConfigType", "ENUM_VALUE": "kDigital"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.REVPHCompressorConfigType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.REVPHCompressorConfigType", "ENUM_VALUE": "kDisabled"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.REVPHCompressorConfigType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.REVPHCompressorConfigType", "ENUM_VALUE": "kHybrid"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.RuntimeType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.RuntimeType", "ENUM_VALUE": "HAL_Runtime_RoboRIO"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.RuntimeType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.RuntimeType", "ENUM_VALUE": "HAL_Runtime_RoboRIO2"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.RuntimeType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.RuntimeType", "ENUM_VALUE": "HAL_Runtime_Simulation"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.SPIMode", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.SPIMode", "ENUM_VALUE": "kMode0"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.SPIMode", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.SPIMode", "ENUM_VALUE": "kMode1"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.SPIMode", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.SPIMode", "ENUM_VALUE": "kMode2"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.SPIMode", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.SPIMode", "ENUM_VALUE": "kMode3"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.SPIPort", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.SPIPort", "ENUM_VALUE": "kInvalid"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.SPIPort", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.SPIPort", "ENUM_VALUE": "kMXP"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.SPIPort", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.SPIPort", "ENUM_VALUE": "kOnboardCS0"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.SPIPort", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.SPIPort", "ENUM_VALUE": "kOnboardCS1"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.SPIPort", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.SPIPort", "ENUM_VALUE": "kOnboardCS2"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.SPIPort", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.SPIPort", "ENUM_VALUE": "kOnboardCS3"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.SerialPort", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.SerialPort", "ENUM_VALUE": "MXP"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.SerialPort", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.SerialPort", "ENUM_VALUE": "Onboard"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.SerialPort", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.SerialPort", "ENUM_VALUE": "USB1"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.SerialPort", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.SerialPort", "ENUM_VALUE": "USB2"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.SimValueDirection", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.SimValueDirection", "ENUM_VALUE": "HAL_SimValueBidir"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.SimValueDirection", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.SimValueDirection", "ENUM_VALUE": "HAL_SimValueInput"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.SimValueDirection", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.SimValueDirection", "ENUM_VALUE": "HAL_SimValueOutput"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.Type", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.Type", "ENUM_VALUE": "BOOLEAN"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.Type", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.Type", "ENUM_VALUE": "DOUBLE"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.Type", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.Type", "ENUM_VALUE": "ENUM"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.Type", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.Type", "ENUM_VALUE": "INT"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.Type", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.Type", "ENUM_VALUE": "LONG"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.Type", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.Type", "ENUM_VALUE": "UNASSIGNED"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kADXL345_I2C"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kADXL345_SPI"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kCANPlugin_2CAN"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kCANPlugin_BlackJagBridge"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kCommand2_Scheduler"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kCommand_Scheduler"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDashboard_AdvantageScope"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDashboard_Elastic"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDashboard_FRCWebComponents"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDashboard_Glass"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDashboard_LabVIEW"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDashboard_QFRCDashboard"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDashboard_Shuffleboard"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDashboard_SmartDashboard"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDashboard_Unknown"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDataLogLocation_Onboard"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDataLogLocation_USB"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDriverStationCIO_Analog"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDriverStationCIO_DigitalIn"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDriverStationCIO_DigitalOut"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDriverStationEIO_Acceleration"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDriverStationEIO_AnalogIn"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDriverStationEIO_AnalogOut"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDriverStationEIO_Button"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDriverStationEIO_DigitalIn"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDriverStationEIO_DigitalOut"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDriverStationEIO_Encoder"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDriverStationEIO_FixedDigitalOut"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDriverStationEIO_LED"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDriverStationEIO_PWM"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kDriverStationEIO_TouchSlider"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kFramework_AdvantageKit"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kFramework_CommandControl"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kFramework_Iterative"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kFramework_MagicBot"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kFramework_ROS"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kFramework_RobotBuilder"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kFramework_Simple"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kFramework_Timed"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kKinematics_DifferentialDrive"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kKinematics_MecanumDrive"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kKinematics_SwerveDrive"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kLanguage_CPlusPlus"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kLanguage_DotNet"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kLanguage_Java"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kLanguage_Kotlin"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kLanguage_LabVIEW"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kLanguage_Python"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kLanguage_Rust"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kLoggingFramework_AdvantageKit"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kLoggingFramework_DogLog"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kLoggingFramework_Epilogue"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kLoggingFramework_Monologue"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kLoggingFramework_Other"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kOdometry_DifferentialDrive"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kOdometry_MecanumDrive"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kOdometry_SwerveDrive"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kPDP_CTRE"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kPDP_REV"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kPDP_Unknown"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kRobotDrive2_DifferentialArcade"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kRobotDrive2_DifferentialCurvature"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kRobotDrive2_DifferentialTank"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kRobotDrive2_KilloughCartesian"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kRobotDrive2_KilloughPolar"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kRobotDrive2_MecanumCartesian"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kRobotDrive2_MecanumPolar"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kRobotDriveSwerve_AdvantageKit"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kRobotDriveSwerve_CTRE"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kRobotDriveSwerve_MaxSwerve"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kRobotDriveSwerve_Other"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kRobotDriveSwerve_YAGSL"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kRobotDrive_ArcadeButtonSpin"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kRobotDrive_ArcadeRatioCurve"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kRobotDrive_ArcadeStandard"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kRobotDrive_MecanumCartesian"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kRobotDrive_MecanumPolar"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kRobotDrive_Tank"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kSmartDashboard_Instance"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tInstances", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tInstances", "ENUM_VALUE": "kSmartDashboard_LiveWindow"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_ADIS16448"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_ADIS16470"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_ADXL345"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_ADXL362"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_ADXRS450"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Accelerometer"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_AddressableLEDs"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_AnalogChannel"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_AnalogOutput"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_AnalogTrigger"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_AnalogTriggerOutput"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_AxisCamera"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_BangBangController"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Button"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_CAN"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_CANJaguar"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_CANPlugin"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_CANTalonSRX"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_CANifier"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_CTRE_future1"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_CTRE_future10"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_CTRE_future11"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_CTRE_future12"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_CTRE_future13"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_CTRE_future14"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_CTRE_future2"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_CTRE_future3"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_CTRE_future4"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_CTRE_future5"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_CTRE_future6"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_CTRE_future7"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_CTRE_future8"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_CTRE_future9"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_ChoreoTrajectory"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_ChoreoTrigger"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Command"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Compressor"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Controller"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Counter"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Dashboard"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_DataLogManager"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_DigilentDMC60"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_DigitalGlitchFilter"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_DigitalInput"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_DigitalOutput"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_DriverStationCIO"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_DriverStationEIO"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_DriverStationLCD"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_DutyCycle"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Encoder"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_ExponentialProfile"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Framework"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_FusionVenom"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_GearTooth"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Gyro"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_HiTechnicAccel"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_HiTechnicColorSensor"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_HiTechnicCompass"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_I2C"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Jaguar"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Joystick"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Kinect"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_KinectStick"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Kinematics"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Koors40"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Language"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_LaserShark"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_LinearFilter"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_LoggingFramework"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_MindsensorsSD540"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Module"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_NavX"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_NidecBrushless"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Odometry"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_PCM"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_PCVideoServer"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_PDP"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_PIDController"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_PIDController2"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_PS4Controller"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_PWFSEN36005"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_PWM"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_PWMTalonSRX"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_PWMVictorSPX"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_PathFindingCommand"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_PathPlannerAuto"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_PathPlannerPath"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_PathWeaverTrajectory"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_PhotonCamera"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_PhotonPoseEstimator"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_PigeonIMU"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Pixy"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Pixy2"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Preferences"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_ProfiledPIDController"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Redux_future1"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Redux_future2"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Redux_future3"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Redux_future4"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Redux_future5"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Relay"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_RevSPARK"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_RevServoHub"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_RevSparkFlexCAN"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_RevSparkFlexPWM"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_RevSparkMaxCAN"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_RevSparkMaxPWM"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_RobotDrive"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_SPI"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_SRF08"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_ScanseSweep"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_SerialPort"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Servo"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Shuffleboard"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_SmartDashboard"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Solenoid"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Talon"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_TalonFX"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Task"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_ThriftyNova"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_TrapezoidProfile"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Ultrasonic"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Units"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_UsbCamera"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_Victor"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_VictorSP"}},
      {"kind": "block", "type": "mrc_get_python_enum_value", "extraState": {"enumType": "hal.tResourceType", "importModule": "hal"}, "fields": {"ENUM_TYPE": "hal.tResourceType", "ENUM_VALUE": "kResourceType_XboxController"}},
    ],
  };
  if (category.contents) {
    category.contents.push(...subcategories);
  }
  return category;
}
