// This file was generated. Do not edit!

import * as toolboxItems from "../../toolbox/items";

// Blocks for class wpimath.estimator.DifferentialDrivePoseEstimator3d

export function initialize() {
}

export function getToolboxCategory(subcategories: toolboxItems.Category[] = []): toolboxItems.Category {

  // There are 13 blocks.
  const contents: toolboxItems.ContentsType[] = [
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myDifferentialDrivePoseEstimator3d"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "constructor", "returnType": "wpimath.estimator.DifferentialDrivePoseEstimator3d", "args": [{"name": "kinematics", "type": "wpimath.kinematics.DifferentialDriveKinematics"}, {"name": "gyroAngle", "type": "wpimath.geometry.Rotation3d"}, {"name": "leftDistance", "type": "wpimath.units.meters"}, {"name": "rightDistance", "type": "wpimath.units.meters"}, {"name": "initialPose", "type": "wpimath.geometry.Pose3d"}], "tooltip": "Constructs a DifferentialDrivePoseEstimator3d with default standard\ndeviations for the model and vision measurements.\n\nThe default standard deviations of the model states are\n0.02 meters for x, 0.02 meters for y, 0.02 meters for z, and 0.01 radians\nfor angle. The default standard deviations of the vision measurements are\n0.1 meters for x, 0.1 meters for y, 0.1 meters for z, and 0.1 radians for\nangle.\n\n:param kinematics:    A correctly-configured kinematics object for your\n                      drivetrain.\n:param gyroAngle:     The gyro angle of the robot.\n:param leftDistance:  The distance traveled by the left encoder.\n:param rightDistance: The distance traveled by the right encoder.\n:param initialPose:   The estimated initial pose.", "importModule": "wpimath.estimator"}, "fields": {"MODULE_OR_CLASS": "wpimath.estimator.DifferentialDrivePoseEstimator3d"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myDifferentialDriveKinematics"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myRotation3d"}}}}, "ARG4": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myPose3d"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myDifferentialDrivePoseEstimator3d"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "constructor", "returnType": "wpimath.estimator.DifferentialDrivePoseEstimator3d", "args": [{"name": "kinematics", "type": "wpimath.kinematics.DifferentialDriveKinematics"}, {"name": "gyroAngle", "type": "wpimath.geometry.Rotation3d"}, {"name": "leftDistance", "type": "wpimath.units.meters"}, {"name": "rightDistance", "type": "wpimath.units.meters"}, {"name": "initialPose", "type": "wpimath.geometry.Pose3d"}, {"name": "stateStdDevs", "type": "Tuple[float, float, float, float]"}, {"name": "visionMeasurementStdDevs", "type": "Tuple[float, float, float, float]"}], "tooltip": "Constructs a DifferentialDrivePoseEstimator3d.\n\n:param kinematics:               A correctly-configured kinematics object for your\n                                 drivetrain.\n:param gyroAngle:                The gyro angle of the robot.\n:param leftDistance:             The distance traveled by the left encoder.\n:param rightDistance:            The distance traveled by the right encoder.\n:param initialPose:              The estimated initial pose.\n:param stateStdDevs:             Standard deviations of the pose estimate (x position in\n                                 meters, y position in meters, z position in meters, and angle in\n                                 radians). Increase these numbers to trust your state estimate less.\n:param visionMeasurementStdDevs: Standard deviations of the vision pose\n                                 measurement (x position in meters, y position in meters, z position in\n                                 meters, and angle in radians). Increase these numbers to trust the vision\n                                 pose measurement less.", "importModule": "wpimath.estimator"}, "fields": {"MODULE_OR_CLASS": "wpimath.estimator.DifferentialDrivePoseEstimator3d"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myDifferentialDriveKinematics"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myRotation3d"}}}}, "ARG4": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myPose3d"}}}}, "ARG5": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTuple"}}}}, "ARG6": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTuple"}}}}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "differentialDrivePoseEstimator3dBase", "type": "wpimath.estimator.DifferentialDrivePoseEstimator3dBase"}, {"name": "visionRobotPose", "type": "wpimath.geometry.Pose3d"}, {"name": "timestamp", "type": "wpimath.units.seconds"}], "tooltip": "Adds a vision measurement to the Kalman Filter. This will correct\nthe odometry pose estimate while still accounting for measurement noise.\n\nThis method can be called as infrequently as you want, as long as you are\ncalling Update() every loop.\n\nTo promote stability of the pose estimate and make it robust to bad vision\ndata, we recommend only adding vision measurements that are already within\none meter or so of the current pose estimate.\n\n:param visionRobotPose: The pose of the robot as measured by the vision\n                        camera.\n:param timestamp:       The timestamp of the vision measurement in seconds. Note\n                        that if you don't use your own time source by calling UpdateWithTime(),\n                        then you must use a timestamp with an epoch since FPGA startup (i.e.,\n                        the epoch of this timestamp is the same epoch as\n                        frc::Timer::GetFPGATimestamp(). This means that you should use\n                        frc::Timer::GetFPGATimestamp() as your time source in this case.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpimath.estimator.DifferentialDrivePoseEstimator3dBase", "FUNC": "addVisionMeasurement"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myDifferentialDrivePoseEstimator3dBase"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myPose3d"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "differentialDrivePoseEstimator3dBase", "type": "wpimath.estimator.DifferentialDrivePoseEstimator3dBase"}, {"name": "visionRobotPose", "type": "wpimath.geometry.Pose3d"}, {"name": "timestamp", "type": "wpimath.units.seconds"}, {"name": "visionMeasurementStdDevs", "type": "Tuple[float, float, float, float]"}], "tooltip": "Adds a vision measurement to the Kalman Filter. This will correct\nthe odometry pose estimate while still accounting for measurement noise.\n\nThis method can be called as infrequently as you want, as long as you are\ncalling Update() every loop.\n\nTo promote stability of the pose estimate and make it robust to bad vision\ndata, we recommend only adding vision measurements that are already within\none meter or so of the current pose estimate.\n\nNote that the vision measurement standard deviations passed into this\nmethod will continue to apply to future measurements until a subsequent\ncall to SetVisionMeasurementStdDevs() or this method.\n\n:param visionRobotPose:          The pose of the robot as measured by the vision\n                                 camera.\n:param timestamp:                The timestamp of the vision measurement in seconds. Note\n                                 that if you don't use your own time source by calling UpdateWithTime(),\n                                 then you must use a timestamp with an epoch since FPGA startup (i.e.,\n                                 the epoch of this timestamp is the same epoch as\n                                 frc::Timer::GetFPGATimestamp(). This means that you should use\n                                 frc::Timer::GetFPGATimestamp() as your time source in this case.\n:param visionMeasurementStdDevs: Standard deviations of the vision pose\n                                 measurement (x position in meters, y position in meters, and heading in\n                                 radians). Increase these numbers to trust the vision pose measurement\n                                 less.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpimath.estimator.DifferentialDrivePoseEstimator3dBase", "FUNC": "addVisionMeasurement"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myDifferentialDrivePoseEstimator3dBase"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myPose3d"}}}}, "ARG3": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTuple"}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myPose3d"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpimath.geometry.Pose3d", "args": [{"name": "differentialDrivePoseEstimator3dBase", "type": "wpimath.estimator.DifferentialDrivePoseEstimator3dBase"}], "tooltip": "Gets the estimated robot pose.\n\n:returns: The estimated robot pose in meters.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpimath.estimator.DifferentialDrivePoseEstimator3dBase", "FUNC": "getEstimatedPosition"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myDifferentialDrivePoseEstimator3dBase"}}}}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "differentialDrivePoseEstimator3dBase", "type": "wpimath.estimator.DifferentialDrivePoseEstimator3dBase"}, {"name": "pose", "type": "wpimath.geometry.Pose3d"}], "tooltip": "Resets the robot's pose.\n\n:param pose: The pose to reset to.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpimath.estimator.DifferentialDrivePoseEstimator3dBase", "FUNC": "resetPose"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myDifferentialDrivePoseEstimator3dBase"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myPose3d"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "differentialDrivePoseEstimator3d", "type": "wpimath.estimator.DifferentialDrivePoseEstimator3d"}, {"name": "gyroAngle", "type": "wpimath.geometry.Rotation3d"}, {"name": "leftDistance", "type": "wpimath.units.meters"}, {"name": "rightDistance", "type": "wpimath.units.meters"}, {"name": "pose", "type": "wpimath.geometry.Pose3d"}], "tooltip": "Resets the robot's position on the field.\n\n:param gyroAngle:     The current gyro angle.\n:param leftDistance:  The distance traveled by the left encoder.\n:param rightDistance: The distance traveled by the right encoder.\n:param pose:          The estimated pose of the robot on the field.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpimath.estimator.DifferentialDrivePoseEstimator3d", "FUNC": "resetPosition"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myDifferentialDrivePoseEstimator3d"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myRotation3d"}}}}, "ARG4": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myPose3d"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "differentialDrivePoseEstimator3dBase", "type": "wpimath.estimator.DifferentialDrivePoseEstimator3dBase"}, {"name": "rotation", "type": "wpimath.geometry.Rotation3d"}], "tooltip": "Resets the robot's rotation.\n\n:param rotation: The rotation to reset to.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpimath.estimator.DifferentialDrivePoseEstimator3dBase", "FUNC": "resetRotation"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myDifferentialDrivePoseEstimator3dBase"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myRotation3d"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "differentialDrivePoseEstimator3dBase", "type": "wpimath.estimator.DifferentialDrivePoseEstimator3dBase"}, {"name": "translation", "type": "wpimath.geometry.Translation3d"}], "tooltip": "Resets the robot's translation.\n\n:param translation: The pose to translation to.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpimath.estimator.DifferentialDrivePoseEstimator3dBase", "FUNC": "resetTranslation"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myDifferentialDrivePoseEstimator3dBase"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTranslation3d"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "Optional[wpimath.geometry._geometry.Pose3d]", "args": [{"name": "differentialDrivePoseEstimator3dBase", "type": "wpimath.estimator.DifferentialDrivePoseEstimator3dBase"}, {"name": "timestamp", "type": "wpimath.units.seconds"}], "tooltip": "Return the pose at a given timestamp, if the buffer is not empty.\n\n:param timestamp: The pose's timestamp.\n\n:returns: The pose at the given timestamp (or std::nullopt if the buffer is\n          empty).", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpimath.estimator.DifferentialDrivePoseEstimator3dBase", "FUNC": "sampleAt"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myDifferentialDrivePoseEstimator3dBase"}}}}}},
    {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "None", "args": [{"name": "differentialDrivePoseEstimator3dBase", "type": "wpimath.estimator.DifferentialDrivePoseEstimator3dBase"}, {"name": "visionMeasurementStdDevs", "type": "Tuple[float, float, float, float]"}], "tooltip": "Sets the pose estimator's trust in vision measurements. This might be used\nto change trust in vision measurements after the autonomous period, or to\nchange trust as distance to a vision target increases.\n\n:param visionMeasurementStdDevs: Standard deviations of the vision pose\n                                 measurement (x position in meters, y position in meters, and heading in\n                                 radians). Increase these numbers to trust the vision pose measurement\n                                 less.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpimath.estimator.DifferentialDrivePoseEstimator3dBase", "FUNC": "setVisionMeasurementStdDevs"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myDifferentialDrivePoseEstimator3dBase"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myTuple"}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myPose3d"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpimath.geometry.Pose3d", "args": [{"name": "differentialDrivePoseEstimator3d", "type": "wpimath.estimator.DifferentialDrivePoseEstimator3d"}, {"name": "gyroAngle", "type": "wpimath.geometry.Rotation3d"}, {"name": "leftDistance", "type": "wpimath.units.meters"}, {"name": "rightDistance", "type": "wpimath.units.meters"}], "tooltip": "Updates the pose estimator with wheel encoder and gyro information. This\nshould be called every loop.\n\n:param gyroAngle:     The current gyro angle.\n:param leftDistance:  The distance traveled by the left encoder.\n:param rightDistance: The distance traveled by the right encoder.\n\n:returns: The estimated pose of the robot.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpimath.estimator.DifferentialDrivePoseEstimator3d", "FUNC": "update"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myDifferentialDrivePoseEstimator3d"}}}}, "ARG1": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myRotation3d"}}}}}}}}},
    {"kind": "block", "type": "variables_set", "fields": {"VAR": {"name": "myPose3d"}}, "inputs": {"VALUE": {"block": {"kind": "block", "type": "mrc_call_python_function", "extraState": {"functionKind": "instance", "returnType": "wpimath.geometry.Pose3d", "args": [{"name": "differentialDrivePoseEstimator3d", "type": "wpimath.estimator.DifferentialDrivePoseEstimator3d"}, {"name": "currentTime", "type": "wpimath.units.seconds"}, {"name": "gyroAngle", "type": "wpimath.geometry.Rotation3d"}, {"name": "leftDistance", "type": "wpimath.units.meters"}, {"name": "rightDistance", "type": "wpimath.units.meters"}], "tooltip": "Updates the pose estimator with wheel encoder and gyro information. This\nshould be called every loop.\n\n:param currentTime:   The time at which this method was called.\n:param gyroAngle:     The current gyro angle.\n:param leftDistance:  The distance traveled by the left encoder.\n:param rightDistance: The distance traveled by the right encoder.\n\n:returns: The estimated pose of the robot.", "importModule": ""}, "fields": {"MODULE_OR_CLASS": "wpimath.estimator.DifferentialDrivePoseEstimator3d", "FUNC": "updateWithTime"}, "inputs": {"ARG0": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myDifferentialDrivePoseEstimator3d"}}}}, "ARG2": {"block": {"type": "variables_get", "fields": {"VAR": {"name": "myRotation3d"}}}}}}}}},
  ];

  contents.push(...subcategories);

  const category: toolboxItems.PythonClassCategory = {
    kind: "category",
    name:  "DifferentialDrivePoseEstimator3d",
    contents: contents,
    className: "wpimath.estimator.DifferentialDrivePoseEstimator3d",
  };

  return category;
}
